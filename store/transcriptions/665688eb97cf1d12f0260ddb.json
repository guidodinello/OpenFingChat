[
    {
        "text": " Después de una semana, nos volvemos a ver las caras.",
        "start": 0.0,
        "end": 20.0
    },
    {
        "text": " Este viniendo para acá y una especie de fiesta fuera, no se bien que es, hay música y todo,",
        "start": 20.0,
        "end": 24.0
    },
    {
        "text": " así que capaz que el terminal a la clase, podemos seguir ahí.",
        "start": 24.0,
        "end": 27.0
    },
    {
        "text": " Pero nuestra fiesta ahora tiene que ver con los tipos de datos.",
        "start": 27.0,
        "end": 31.0
    },
    {
        "text": " Porque hoy vamos a seguir hablando de los diferentes tipos de datos de los que disponemos en Pascal.",
        "start": 31.0,
        "end": 41.0
    },
    {
        "text": " A grandes rasgos vimos que los tipos de datos se podían clasificar en dos grandes grupos.",
        "start": 41.0,
        "end": 53.0
    },
    {
        "text": " Por un lado, están los tipos de datos predefinidos por el lenguaje, los que ya vienen con Pascal.",
        "start": 53.0,
        "end": 66.0
    },
    {
        "text": " Aquellos con los cuales empezamos a trabajar. ¿Cuál será?",
        "start": 66.0,
        "end": 73.0
    },
    {
        "text": " Teníamos el bulyan, teníamos el indeller, teníamos el char y teníamos cuál.",
        "start": 73.0,
        "end": 87.0
    },
    {
        "text": " Y también teníamos el real.",
        "start": 87.0,
        "end": 91.0
    },
    {
        "text": " Eso serán los tipos de datos predefinidos por el lenguaje de programación.",
        "start": 91.0,
        "end": 98.0
    },
    {
        "text": " Luego venieron los tipos de datos definidos por el programador.",
        "start": 98.0,
        "end": 108.0
    },
    {
        "text": " Los tipos de datos que nosotros podemos crear dentro de nuestros programas.",
        "start": 108.0,
        "end": 115.0
    },
    {
        "text": " Y había una sección específica para eso. ¿Qué palabra le identificaba?",
        "start": 115.0,
        "end": 120.0
    },
    {
        "text": " Type. La palabra reservada Type.",
        "start": 120.0,
        "end": 124.0
    },
    {
        "text": " Es la que nosotros utilizábamos para definir nuestros propios tipos de datos por fuera de los que ya vienen predefinidos por Pascal.",
        "start": 124.0,
        "end": 135.0
    },
    {
        "text": " Bien.",
        "start": 135.0,
        "end": 138.0
    },
    {
        "text": " Y dentro de los tipos de datos definidos por el programador, a su vez tenemos tres grandes grupos.",
        "start": 138.0,
        "end": 146.0
    },
    {
        "text": " Los primeros que vimos cual fueron. Los subrangos.",
        "start": 147.0,
        "end": 155.0
    },
    {
        "text": " Nosotros podíamos definir subrangos de tipos ya existentes, siempre que fueran tipos como.",
        "start": 155.0,
        "end": 165.0
    },
    {
        "text": " Empezaba con o. Ordinales.",
        "start": 165.0,
        "end": 170.0
    },
    {
        "text": " Bien. Los primeros que vimos fueron subrangos de tipos ordinales.",
        "start": 171.0,
        "end": 175.0
    },
    {
        "text": " Que de hecho, hoy vamos a hablar más en detalle de los tipos ordinales.",
        "start": 175.0,
        "end": 180.0
    },
    {
        "text": " Luego vienen los enumerados que son otra categoría de tipos de datos que el programador puede definir.",
        "start": 180.0,
        "end": 190.0
    },
    {
        "text": " Que también los vamos a mencionar hoy.",
        "start": 190.0,
        "end": 194.0
    },
    {
        "text": " Y por último estaban los tipos de datos estructurados.",
        "start": 194.0,
        "end": 199.0
    },
    {
        "text": " Que se refería a aquellos tipos de datos que me permitían englobar varios valores juntos dentro de una misma variable.",
        "start": 199.0,
        "end": 210.0
    },
    {
        "text": " Y dentro de los estructurados habíamos visto cuales.",
        "start": 210.0,
        "end": 215.0
    },
    {
        "text": " Los. Los huye.",
        "start": 215.0,
        "end": 220.0
    },
    {
        "text": " Los arreglos.",
        "start": 220.0,
        "end": 223.0
    },
    {
        "text": " Nosotros dentro de una reglo que almacenábamos.",
        "start": 224.0,
        "end": 229.0
    },
    {
        "text": " Más fuerte porque yo soy sordo, no escucho.",
        "start": 231.0,
        "end": 234.0
    },
    {
        "text": " Valores. Y que tenían que cumplir esos valores.",
        "start": 234.0,
        "end": 239.0
    },
    {
        "text": " Tenían que ser del mismo tipo de datos que el arreglo.",
        "start": 241.0,
        "end": 246.0
    },
    {
        "text": " Y los lugares dentro del arreglo en los que guardábamos valores como se llamaban.",
        "start": 246.0,
        "end": 252.0
    },
    {
        "text": " Si llamaban celdas y cada celdas está identificada por un índice.",
        "start": 252.0,
        "end": 257.0
    },
    {
        "text": " Está bien. Y los valores que poníamos dentro de todas las celdas tenían que ser todos del mismo tipo que debía coincidir con el tipo de la declaración del arreglo.",
        "start": 257.0,
        "end": 268.0
    },
    {
        "text": " Eso fueron los primeros tipos estructurados que vimos.",
        "start": 268.0,
        "end": 273.0
    },
    {
        "text": " Los arreglos.",
        "start": 273.0,
        "end": 276.0
    },
    {
        "text": " Hoy vamos a hablar también de los conjuntos que son otra clase de tipo estructurado que nosotros podemos definir.",
        "start": 276.0,
        "end": 288.0
    },
    {
        "text": " Y por último van a venir también los registros que son otra clase más de tipo estructurado que nosotros podemos definir.",
        "start": 288.0,
        "end": 301.0
    },
    {
        "text": " O sea que tenemos los predefinidos que son aquellos 4.",
        "start": 302.0,
        "end": 306.0
    },
    {
        "text": " Y después están los que nosotros podemos definir utilizando la palabra TIE.",
        "start": 306.0,
        "end": 313.0
    },
    {
        "text": " Y dentro de los que podemos definir utilizando la palabra TIE tenemos subrangos enumerados estructurados.",
        "start": 313.0,
        "end": 320.0
    },
    {
        "text": " Y estos últimos azubes pueden ser arreglos conjuntos y registros.",
        "start": 320.0,
        "end": 325.0
    },
    {
        "text": " Hoy vamos a terminar de ver de todo este esquema lo que nos falta ver.",
        "start": 326.0,
        "end": 331.0
    },
    {
        "text": " Concretamente nos falta hablar de los enumerados que lo vamos a hacer hoy.",
        "start": 331.0,
        "end": 336.0
    },
    {
        "text": " Nos falta hablar de los conjuntos y también de los registros.",
        "start": 336.0,
        "end": 340.0
    },
    {
        "text": " Y con eso vamos a tener todo el esquema de posibles tipos de datos con los que podemos trabajar.",
        "start": 340.0,
        "end": 346.0
    },
    {
        "text": " Hasta acá.",
        "start": 346.0,
        "end": 349.0
    },
    {
        "text": " Bien. Algunos de esos tipos de datos.",
        "start": 349.0,
        "end": 353.0
    },
    {
        "text": " Concretamente estos que están acá junto con estos otros que estoy marcando acá son lo que llamamos tipos como ordinales.",
        "start": 355.0,
        "end": 369.0
    },
    {
        "text": " O sea, real y todos estos quedan por fuera de lo que llamamos tipos ordinales.",
        "start": 374.0,
        "end": 381.0
    },
    {
        "text": " Observen que hay tipos ordinales que ya vienen predefinidos por el lenguaje,",
        "start": 381.0,
        "end": 386.0
    },
    {
        "text": " bullian char intesher y también hay tipos ordinales que podemos definir nosotros, subrangos y enumerados.",
        "start": 386.0,
        "end": 394.0
    },
    {
        "text": " Lo que tienen en común todos los tipos ordinales es que los valores que los conforman podemos imaginar que están de alguna manera colocados en una especie de hilera imaginaria,",
        "start": 394.0,
        "end": 409.0
    },
    {
        "text": " uno al lado de otro y se pueden ordenar de ahí que se llaman ordinales.",
        "start": 409.0,
        "end": 416.0
    },
    {
        "text": " Hay un primer elemento del conjunto, hay un segundo elemento, hay un tercer elemento y entre dos de ellos que están pegaditos no hay ningún otro.",
        "start": 416.0,
        "end": 426.0
    },
    {
        "text": " Esa es un poquito la idea de tipo ordinal y tanto los ordinales como los reales, es decir, ordinales más.",
        "start": 426.0,
        "end": 444.0
    },
    {
        "text": " El tipo real son tipos de datos como, que se va a conocer.",
        "start": 444.0,
        "end": 451.0
    },
    {
        "text": " No, tipos de datos simples, es decir, no estructurados.",
        "start": 451.0,
        "end": 460.0
    },
    {
        "text": " Esto es un poco todo el panorama de los tipos de datos que existen en Pascal.",
        "start": 463.0,
        "end": 469.0
    },
    {
        "text": " Y como dije antes, hoy vamos a terminar de ver los que nos faltan.",
        "start": 470.0,
        "end": 476.0
    },
    {
        "text": " ¿Preguntas de esto?",
        "start": 476.0,
        "end": 479.0
    },
    {
        "text": " Bueno, vamos a empezar por hablar un poco más en detalle de los tipos ordinales.",
        "start": 479.0,
        "end": 485.0
    },
    {
        "text": " Enseguida de eso nos vamos a meter más en los enumerados, luego vamos a hablar un poquito de conjuntos y después nos vamos a meter de lleno en los registros.",
        "start": 485.0,
        "end": 495.0
    },
    {
        "text": " Ordinales enumerados y conjuntos es de lo que vamos a hablar ahora.",
        "start": 496.0,
        "end": 502.0
    },
    {
        "text": " Empezamos por los tipos ordinales.",
        "start": 502.0,
        "end": 507.0
    },
    {
        "text": " Los tipos ordinales, el libro también les dice tipos escalares, son todos estos que fueron los que acabamos de mencionar.",
        "start": 507.0,
        "end": 517.0
    },
    {
        "text": " Enteros, caracteres, bulianos, subrangos y enumerados.",
        "start": 517.0,
        "end": 522.0
    },
    {
        "text": " Representan en algún sentido lo que vendría a ser, dicho de una manera bastante simplificada, con juntos discretos, con juntos inumerables, con juntos de valores cuyos elementos se pueden de alguna manera ordenar en fila.",
        "start": 523.0,
        "end": 541.0
    },
    {
        "text": " Todos ellos, tanto los tres que ya vienen predefinidos como los dos que definimos nosotros, poseen las funciones pred sux y ordo.",
        "start": 542.0,
        "end": 555.0
    },
    {
        "text": " ¿Qué hacía, por ejemplo, sux?",
        "start": 555.0,
        "end": 557.0
    },
    {
        "text": " Dado un valor de un tipo ordinal que devuelve el valor siguiente de ese tipo ordinal.",
        "start": 557.0,
        "end": 565.0
    },
    {
        "text": " La función pred devuelve el valor anterior de ese tipo ordinal y la función ord, lo que hace es devuelve la codificación interna que la máquina hace de un valor dado del tipo ordinal.",
        "start": 565.0,
        "end": 583.0
    },
    {
        "text": " Nosotros lo habíamos visto puntualmente sobre cual de los tipos ordinales ordo.",
        "start": 583.0,
        "end": 588.0
    },
    {
        "text": " Sobre el tipo char, yo le pasaba un carácter y que me devolvía ordo.",
        "start": 588.0,
        "end": 595.0
    },
    {
        "text": " ¿Cómo?",
        "start": 595.0,
        "end": 596.0
    },
    {
        "text": " Un número, sí, que era el número correspondiente de la codificación interna de los caracteres.",
        "start": 596.0,
        "end": 603.0
    },
    {
        "text": " ¿Qué hemos visto para fripascaler al código aquí?",
        "start": 603.0,
        "end": 606.0
    },
    {
        "text": " Bueno, ordo no solamente se aplica a los caracteres sino que se aplica a cualquier tipo ordinal por detrás del tipo ordinal, los valores que pertenecen a ese tipo internamente tienen un sistema de numeración.",
        "start": 607.0,
        "end": 620.0
    },
    {
        "text": " ¿Está? Hay un primer valor, hay un segundo valor, hay un tercero y así, y lo que hace la función ord es devolverme, bueno, que el lugar, digamos, ocupa dentro del orden de los valores del tipo.",
        "start": 620.0,
        "end": 634.0
    },
    {
        "text": " Sí.",
        "start": 634.0,
        "end": 635.0
    },
    {
        "text": " De los predefinidos, el único que no es ordinal es el tipo real.",
        "start": 637.0,
        "end": 642.0
    },
    {
        "text": " Y en el libro, como dijimos, a los tipos ordinales se lo llama tipos escalares también.",
        "start": 642.0,
        "end": 648.0
    },
    {
        "text": " Bien.",
        "start": 648.0,
        "end": 649.0
    },
    {
        "text": " Entonces,",
        "start": 652.0,
        "end": 654.0
    },
    {
        "text": " Y aquí algunas construcciones del lenguaje que trabajan específicamente con valores de tipos ordinales.",
        "start": 655.0,
        "end": 664.0
    },
    {
        "text": " Por ejemplo, la variable de control de un for, sí, debe ser de un tipo ordinal.",
        "start": 664.0,
        "end": 672.0
    },
    {
        "text": " La gran mayoría de las veces que usamos, int-yere.",
        "start": 672.0,
        "end": 676.0
    },
    {
        "text": " Pero por ejemplo, yo podía usar una variable de tipo char como variable de control de un for.",
        "start": 677.0,
        "end": 682.0
    },
    {
        "text": " Bueno, no solamente int-yere, no solamente char, sino que cualquier tipo ordinal es admisible para la variable de control de un for.",
        "start": 682.0,
        "end": 692.0
    },
    {
        "text": " O sea, ese es un lugar donde el tipo necesariamente debe ser ordinal.",
        "start": 693.0,
        "end": 698.0
    },
    {
        "text": " Yo no puedo usar real como variable de control de un for.",
        "start": 698.0,
        "end": 702.0
    },
    {
        "text": " La expresión que colocamos en un case también debe pertenecer algún tipo ordinal.",
        "start": 703.0,
        "end": 710.0
    },
    {
        "text": " O sea, no puede ser real y mucho menos puede ser estructurado.",
        "start": 710.0,
        "end": 715.0
    },
    {
        "text": " Sí.",
        "start": 715.0,
        "end": 717.0
    },
    {
        "text": " Los índices que usamos para identificar las celdas de un arreglo también dijimos que debían ser de un tipo ordinal.",
        "start": 717.0,
        "end": 725.0
    },
    {
        "text": " La gran mayoría de las veces nosotros usamos un subrango de que.",
        "start": 725.0,
        "end": 730.0
    },
    {
        "text": " Denteros, pero se puede usar subrango de cualquier tipo ordinal para los índices de un arreglo.",
        "start": 731.0,
        "end": 738.0
    },
    {
        "text": " Y en un ratito cuando olemos de los conjuntos, vamos a ver que en Pascal los conjuntos pueden almacenar únicamente valores de tipos ordinales.",
        "start": 739.0,
        "end": 749.0
    },
    {
        "text": " Eso de hecho es una restricción del lenguaje. Podría existir otro lenguaje que por ejemplo admita definir conjuntos de reales.",
        "start": 750.0,
        "end": 757.0
    },
    {
        "text": " Pero en Pascal únicamente tienen que ser tipos ordinales.",
        "start": 758.0,
        "end": 762.0
    },
    {
        "text": " Quedan claros los tipos ordinales.",
        "start": 763.0,
        "end": 766.0
    },
    {
        "text": " Siguiendo, vamos a hablar ahora de los enumerados.",
        "start": 767.0,
        "end": 771.0
    },
    {
        "text": " Ya habíamos visto los predefinidos que eran cuales.",
        "start": 772.0,
        "end": 775.0
    },
    {
        "text": " Integer, Char y Búlia.",
        "start": 777.0,
        "end": 780.0
    },
    {
        "text": " Ya habíamos visto antes los subrango, nos restan ver los enumerados y con eso completamos los tipos ordinales.",
        "start": 780.0,
        "end": 786.0
    },
    {
        "text": " Y la idea de los enumerados es poder representar un conjunto de valores que tiene una cantidad fija de elementos.",
        "start": 790.0,
        "end": 800.0
    },
    {
        "text": " Yo quiero representar algún dato que toma un valor dentro de un conjunto de valores posibles.",
        "start": 801.0,
        "end": 809.0
    },
    {
        "text": " Y lo que tienen esos conjuntos de valores posibles es que son finidos.",
        "start": 812.0,
        "end": 817.0
    },
    {
        "text": " Por ejemplo, a mí me gustaría poder representar los días de la semana.",
        "start": 818.0,
        "end": 822.0
    },
    {
        "text": " Si, lo unes Martes, miércoles, viernes, sábados, domingo.",
        "start": 823.0,
        "end": 827.0
    },
    {
        "text": " Quiero tener una variable dentro de la cual yo pueda almacenar un día de la semana.",
        "start": 828.0,
        "end": 833.0
    },
    {
        "text": " Bueno, para los días de la semana nosotros vamos a definir un enumerado.",
        "start": 835.0,
        "end": 839.0
    },
    {
        "text": " Como ordinales que son internamente van a tener un valor numérico que los representa.",
        "start": 842.0,
        "end": 848.0
    },
    {
        "text": " Y de hecho, podrían representarse como enteros.",
        "start": 849.0,
        "end": 853.0
    },
    {
        "text": " Yo me podría definir un subrango que vaya de 1 a 7.",
        "start": 854.0,
        "end": 857.0
    },
    {
        "text": " El 1 lo voy a usar para el lunes.",
        "start": 860.0,
        "end": 862.0
    },
    {
        "text": " El 2 para el Martes, el 3 para el miércoles.",
        "start": 863.0,
        "end": 865.0
    },
    {
        "text": " Eso lo puedo hacer, pero no es lo bastante expresivo.",
        "start": 866.0,
        "end": 869.0
    },
    {
        "text": " A mí me gustaría poder guardar en una variable el valor domingo o el valor lunes.",
        "start": 871.0,
        "end": 877.0
    },
    {
        "text": " Pero, por ejemplo, yo quiero que los dias de nombre a los valores que yo quiero almacenar.",
        "start": 878.0,
        "end": 883.0
    },
    {
        "text": " Y eso es lo que nos van a permitirlos enumerados.",
        "start": 884.0,
        "end": 887.0
    },
    {
        "text": " También podría usar, por ejemplo, letras de tipo char para no se guardar las iniciales de los días.",
        "start": 889.0,
        "end": 896.0
    },
    {
        "text": " Pero eso tampoco es lo bastante expresivo.",
        "start": 897.0,
        "end": 899.0
    },
    {
        "text": " Yo quiero poder tener un conjunto de valores que representa los días de la semana y que se llamen del 1 a domingo.",
        "start": 900.0,
        "end": 907.0
    },
    {
        "text": " Los meses del año van a haber montones de situaciones en las cuales tenemos un conjunto de valores fijo de tamaño fijo,",
        "start": 908.0,
        "end": 917.0
    },
    {
        "text": " que yo quiero poder guardar dentro de una variable.",
        "start": 918.0,
        "end": 922.0
    },
    {
        "text": " Y eso son los enumerados.",
        "start": 923.0,
        "end": 925.0
    },
    {
        "text": " Como todo tipo de datos definido por nosotros, se define dentro de la sección type del programa.",
        "start": 928.0,
        "end": 935.0
    },
    {
        "text": " Y para definir un enumerado, se hace lo siguiente.",
        "start": 936.0,
        "end": 939.0
    },
    {
        "text": " Se coloca el nombre que le vamos a dar al tipo de datos.",
        "start": 940.0,
        "end": 945.0
    },
    {
        "text": " Y entre paréntesis se colocan los valores que pertenecen a ese tipo de datos.",
        "start": 946.0,
        "end": 953.0
    },
    {
        "text": " Día semana es un nuevo tipo de datos que no es ni un subrango ni un subconjunto de los caracteres,",
        "start": 954.0,
        "end": 966.0
    },
    {
        "text": " sino que es un tipo enumerado.",
        "start": 967.0,
        "end": 969.0
    },
    {
        "text": " Yo estoy enumerando los valores que pertenecen al tipo de datos.",
        "start": 970.0,
        "end": 972.0
    },
    {
        "text": " Entonces, por ejemplo, yo me podría declarar en la sección de variables del programa.",
        "start": 976.0,
        "end": 980.0
    },
    {
        "text": " Me podría declarar una variable de tipo de semana.",
        "start": 984.0,
        "end": 989.0
    },
    {
        "text": " Esto es el nombre del tipo de datos, de su variable de ese tipo de datos.",
        "start": 993.0,
        "end": 1000.0
    },
    {
        "text": " Y más adelante, dentro del cuerpo, del programa, yo a la variable de, le podría asignar, por ejemplo, el valor martes.",
        "start": 1001.0,
        "end": 1009.0
    },
    {
        "text": " O sea, ven que no lo puse entre comillas, porque no es un carácter.",
        "start": 1010.0,
        "end": 1017.0
    },
    {
        "text": " Es un valor de tipo que, de tipo de semana, que es un tipo enumerado.",
        "start": 1018.0,
        "end": 1026.0
    },
    {
        "text": " Me puedo definir, por ejemplo, el tipo enumerado mes para representar los meses del año.",
        "start": 1029.0,
        "end": 1035.0
    },
    {
        "text": " Y entreparentes, y separando con comas de fino exáustivamente todos los posibles valores, que puede tomar una variable de tipo mes.",
        "start": 1036.0,
        "end": 1045.0
    },
    {
        "text": " Lo mismo si quiero representar los puntos cardinales.",
        "start": 1046.0,
        "end": 1049.0
    },
    {
        "text": " Para estas cosas es que nos sirven los enumerados.",
        "start": 1051.0,
        "end": 1054.0
    },
    {
        "text": " ¿A bien?",
        "start": 1055.0,
        "end": 1056.0
    },
    {
        "text": " Sí.",
        "start": 1057.0,
        "end": 1058.0
    },
    {
        "text": " Pascal no es que es sensitive, o sea que no habría diferencia.",
        "start": 1059.0,
        "end": 1064.0
    },
    {
        "text": " Y, igual por un tema de claridad, se recomienda definirlo siempre tal y como está.",
        "start": 1065.0,
        "end": 1068.0
    },
    {
        "text": " De hecho, los valores que vos definís cumplen las mismas reglas que los identificadores.",
        "start": 1070.0,
        "end": 1075.0
    },
    {
        "text": " Los identificadores que eran los nombres que nosotros le dábamos a cosas como las variables, los procedimientos o las funciones.",
        "start": 1077.0,
        "end": 1083.0
    },
    {
        "text": " Los valores de un enumerado también son identificadores.",
        "start": 1084.0,
        "end": 1087.0
    },
    {
        "text": " Pascal.",
        "start": 1091.0,
        "end": 1092.0
    },
    {
        "text": " Digimos además que los tipos enumerados son también tipos ordinales, o sea que internamente cada valor del tipo enumerado tiene asociado un código entero y les cuento que ese código empieza al cero.",
        "start": 1093.0,
        "end": 1108.0
    },
    {
        "text": " Si yo le aplico la función ord a domingo, me va a devolver cero.",
        "start": 1109.0,
        "end": 1115.0
    },
    {
        "text": " Si le aplico la función ord alunes, me va a devolver uno, dos para martes y así hasta llegar a seis.",
        "start": 1116.0,
        "end": 1122.0
    },
    {
        "text": " Pero repito, no es de interés trabajar con los valores numéricos, sino trabajar espremente con los nombres de los valores del tipo enumerado.",
        "start": 1125.0,
        "end": 1133.0
    },
    {
        "text": " Bueno, lo que tenemos ahí es la sintaxis generica para definir un tipo enumerado dentro de la sección type, se le pone un nombre, un identificador del tipo de datos, este chirimbollo no lo de en pelota,",
        "start": 1139.0,
        "end": 1153.0
    },
    {
        "text": " un igual y entre paréntesis los distintos valores del enumerado que de nuevo.",
        "start": 1154.0,
        "end": 1159.0
    },
    {
        "text": " No son enteros, no son caracteres, sino que son nombres, son identificadores.",
        "start": 1160.0,
        "end": 1167.0
    },
    {
        "text": " No se ponen entre comillas y no pueden ser valores numéricos, cosas como lunes, martes miércoles, esas cosas son las que ponemos como valores posibles de un enumerado.",
        "start": 1168.0,
        "end": 1178.0
    },
    {
        "text": " Le tras pero cinco millas, o sea si vos pones una entre comillas, eso es un char, no es admisible.",
        "start": 1180.0,
        "end": 1187.0
    },
    {
        "text": " Si vos pones a solo cinco millas, ¿a sería un valor posible del tipo enumerado?",
        "start": 1187.0,
        "end": 1192.0
    },
    {
        "text": " Sí, no, eso quedó un error de pipeo, no le de en pelota.",
        "start": 1192.0,
        "end": 1197.0
    },
    {
        "text": " Hasta acá, sí, no puede ser un número, o sea, podés tener un número en algún lugar dentro del identificador de la misma manera que lo podés tener en el nombre de una variable, pero no pueden empezar con número, ni ser solo un número.",
        "start": 1199.0,
        "end": 1214.0
    },
    {
        "text": " Bien, definiciones de enumerados que no van a compilar.",
        "start": 1215.0,
        "end": 1223.0
    },
    {
        "text": " Acá estoy queriendo definir un conjunto de números pares, de dígitos pares como un enumerado, esto no compila, porque estos no son nombres, son constantes numéricas.",
        "start": 1224.0,
        "end": 1238.0
    },
    {
        "text": " Tampoco puedo definir letras entre comillas, porque eso serían caracteres.",
        "start": 1239.0,
        "end": 1245.0
    },
    {
        "text": " Debo poner específicamente el nombre que yo le quiero dar a cada valor del tipo enumerado, por ejemplo, martes.",
        "start": 1245.0,
        "end": 1252.0
    },
    {
        "text": " Bien, ¿qué operaciones tenemos definidas para los enumerados?",
        "start": 1257.0,
        "end": 1263.0
    },
    {
        "text": " Las comparaciones dadas por los operadores relacionales de la misma manera que tenemos definidas para cualquier tipo ordinal.",
        "start": 1264.0,
        "end": 1271.0
    },
    {
        "text": " Las funciones SUX-PRED-YOR, que tampoco está listada, también aplicables a cualquier tipo ordinal son aplicables a los enumerados.",
        "start": 1272.0,
        "end": 1282.0
    },
    {
        "text": " O sea, iré dan toda operación que pueda aplicarse sobre un tipo ordinal.",
        "start": 1282.0,
        "end": 1287.0
    },
    {
        "text": " Y acabemos en acción la función ORMO.",
        "start": 1288.0,
        "end": 1293.0
    },
    {
        "text": " Si yo le paso el mes enero, que era el primer mes del tipo enumerado mes, me va a devolver 0.",
        "start": 1294.0,
        "end": 1300.0
    },
    {
        "text": " Si yo le paso febrero, me va a devolver 1 y así con cada valor del enumerado.",
        "start": 1300.0,
        "end": 1305.0
    },
    {
        "text": " Y también se puede hacer al revés, dado el código numérico, cuáles el valor del tipo numérado asociado ese código numérico.",
        "start": 1306.0,
        "end": 1317.0
    },
    {
        "text": " Eso se hace usando el nombre del tipo de datos como si fuese el nombre de una función.",
        "start": 1318.0,
        "end": 1324.0
    },
    {
        "text": " Si yo pongo mes, que es el nombre del tipo numérado y le paso un 0, eso me va a devolver como resultado el valor enero.",
        "start": 1324.0,
        "end": 1333.0
    },
    {
        "text": " Si le paso un 1 febrero y así, o sea, existe unida y vuelta entre los valores del enumerado y los valores numéricos que los representan por detrás.",
        "start": 1334.0,
        "end": 1343.0
    },
    {
        "text": " Y así con cualquier tipo ordinal.",
        "start": 1344.0,
        "end": 1347.0
    },
    {
        "text": " Bueno, cosas que podemos hacer con un enumerado.",
        "start": 1350.0,
        "end": 1354.0
    },
    {
        "text": " Por ejemplo, leerlo del entrada estándar.",
        "start": 1354.0,
        "end": 1357.0
    },
    {
        "text": " Ahora bien, yo no puedo aplicar directamente RID o RID, la en sobre un valor de un tipo enumerado.",
        "start": 1358.0,
        "end": 1365.0
    },
    {
        "text": " Por eso dice así que no es posible hacer RID con enumerados.",
        "start": 1366.0,
        "end": 1370.0
    },
    {
        "text": " Entonces, lo vamos a leer de una manera indirecta, vamos a leer lo que sería el número de mes y después dentro del procedimiento lo vamos a transformar en el valor correspondiente de ese mes.",
        "start": 1371.0,
        "end": 1382.0
    },
    {
        "text": " Tenemos aquí un procedimiento, se llama lm y tiene un parámetro m que es el mes que queremos leer.",
        "start": 1383.0,
        "end": 1391.0
    },
    {
        "text": " De qué manera fue pasado ese parámetro? Por referencia, cuando es que nosotros pasamos un parámetro por referencia.",
        "start": 1392.0,
        "end": 1398.0
    },
    {
        "text": " Cuando queremos modificar el valor de la variable que estamos pasando por paratro.",
        "start": 1400.0,
        "end": 1406.0
    },
    {
        "text": " En este caso modificándola porque le estamos cargando por teclado.",
        "start": 1407.0,
        "end": 1410.0
    },
    {
        "text": " Declaramos una variable local mesaux, que es un valor entero en el subrango 012 y lo que le pedimos al usuario no es que escriba el nombre del mes.",
        "start": 1413.0,
        "end": 1423.0
    },
    {
        "text": " Le pedimos que escriba un valor numérico entre 1 y 12.",
        "start": 1423.0,
        "end": 1427.0
    },
    {
        "text": " El usuario me ingresa el valor de ese mes.",
        "start": 1429.0,
        "end": 1432.0
    },
    {
        "text": " Por ejemplo, 3, ¿qué mes está queriendo ingresar? Marzo.",
        "start": 1432.0,
        "end": 1437.0
    },
    {
        "text": " Sin embargo, cuando hago la conversión al valor del enumerado le tengo que arrestar 1, ¿por qué?",
        "start": 1438.0,
        "end": 1442.0
    },
    {
        "text": " Porque internamente empezaban en 0, o sea, el 0 es en 0, el 1 es en 0, marzo va a ser el 2.",
        "start": 1443.0,
        "end": 1449.0
    },
    {
        "text": " Por eso es que el resto 1 lo convierto a un valor de tipo mes y eso es lo que guardan en el mes.",
        "start": 1450.0,
        "end": 1456.0
    },
    {
        "text": " Entonces de esa manera, logré leer del entrada standard un valor para mes.",
        "start": 1459.0,
        "end": 1464.0
    },
    {
        "text": " ¿Cómo? Internamente van de 0 a 11.",
        "start": 1467.0,
        "end": 1472.0
    },
    {
        "text": " O sea, el usuario me va a ingresar entre 1 y 12, pero la codificación de entrada de pascal va entre 0 y 11, por eso es que le resta 1.",
        "start": 1472.0,
        "end": 1479.0
    },
    {
        "text": " O sea, esto es el posible rango de valores que estamos manejando.",
        "start": 1482.0,
        "end": 1486.0
    },
    {
        "text": " ¿Tendría que ser de 1 a 12?",
        "start": 1487.0,
        "end": 1491.0
    },
    {
        "text": " Tendría que ser de 1 a 2, no porque el usuario no va a ingresar 1, 0.",
        "start": 1491.0,
        "end": 1498.0
    },
    {
        "text": " Sin ingresar 1, 0 queda negativo, sí, podría arrancar en 1.",
        "start": 1500.0,
        "end": 1504.0
    },
    {
        "text": " Está mal igual que arranque en 0, o sea, falla el programa.",
        "start": 1504.0,
        "end": 1507.0
    },
    {
        "text": " No, hay un valor que no vamos a usar nunca, pero por lo demás, andaba bien.",
        "start": 1507.0,
        "end": 1512.0
    },
    {
        "text": " ¿No te merees...",
        "start": 1513.0,
        "end": 1515.0
    },
    {
        "text": " Sí.",
        "start": 1515.0,
        "end": 1516.0
    },
    {
        "text": " ¿Hay un mes a 1?",
        "start": 1516.0,
        "end": 1518.0
    },
    {
        "text": " Sí.",
        "start": 1518.0,
        "end": 1519.0
    },
    {
        "text": " ¿Sí?",
        "start": 1519.0,
        "end": 1520.0
    },
    {
        "text": " Sí, 2, y un mes es compatible igual en 1.",
        "start": 1520.0,
        "end": 1522.0
    },
    {
        "text": " ¿Mes a 1?",
        "start": 1522.0,
        "end": 1524.0
    },
    {
        "text": " Está bien, porque si el usuario ingres a 1, que es enero, al restarle 1, me tiene que quedar 0 y para que no se vaya a arrangar, tiene que empezar en 0.",
        "start": 1524.0,
        "end": 1532.0
    },
    {
        "text": " Es por eso, para el caso borde de enero.",
        "start": 1532.0,
        "end": 1535.0
    },
    {
        "text": " ¿Se entendió de este?",
        "start": 1537.0,
        "end": 1539.0
    },
    {
        "text": " Bien.",
        "start": 1539.0,
        "end": 1541.0
    },
    {
        "text": " Sí.",
        "start": 1542.0,
        "end": 1543.0
    },
    {
        "text": " O sea, el mes tiene dos elementos, 0 a 12.",
        "start": 1544.0,
        "end": 1550.0
    },
    {
        "text": " Desde 0 a 11 es la codificación interna de Pascal, el usuario te va a ingresar de 1 a 12.",
        "start": 1550.0,
        "end": 1555.0
    },
    {
        "text": " ¿Y creo que me es que es la codificación interna, cortón?",
        "start": 1557.0,
        "end": 1560.0
    },
    {
        "text": " O sea, si el usuario te ingres a 1, que es enero, acá le restamos 1, te queda 0 y 0 es la codificación interna de enero, va a quedar enero guardado enema.",
        "start": 1560.0,
        "end": 1570.0
    },
    {
        "text": " ¿Y si tuviéramos de 1 a 12, como que estás operando con 1 a 12?",
        "start": 1572.0,
        "end": 1577.0
    },
    {
        "text": " Si, ¿estuviera de finio de 1 a 12, que cosa?",
        "start": 1577.0,
        "end": 1579.0
    },
    {
        "text": " Me está 1.",
        "start": 1579.0,
        "end": 1580.0
    },
    {
        "text": " No, no, tiene que estar definido de 0 a 12, porque si le ingresa 1 al restarle 1, te tiene que quedar un valor dentro de rango.",
        "start": 1580.0,
        "end": 1586.0
    },
    {
        "text": " Eso es lo que es la codificación.",
        "start": 1586.0,
        "end": 1588.0
    },
    {
        "text": " Por eso es que está de 0 a 12 y no de 1 a 12, sí.",
        "start": 1588.0,
        "end": 1590.0
    },
    {
        "text": " Suponemos que no porque el usuario le pedimos de 1 a 12.",
        "start": 1596.0,
        "end": 1599.0
    },
    {
        "text": " Pusimos el 0 no más por el tema de restarle 1 y que pueda asignar el primer valor del enumerado.",
        "start": 1600.0,
        "end": 1605.0
    },
    {
        "text": " Si.",
        "start": 1605.0,
        "end": 1606.0
    },
    {
        "text": " Si su quisiera que el usuario ingresara el nombre de es mes y lo que le podría no.",
        "start": 1606.0,
        "end": 1611.0
    },
    {
        "text": " Tendría que trabajar con algo que aún no hemos visto que son strings.",
        "start": 1611.0,
        "end": 1615.0
    },
    {
        "text": " Todavía no.",
        "start": 1615.0,
        "end": 1616.0
    },
    {
        "text": " ¿Más preguntas de espesi?",
        "start": 1618.0,
        "end": 1620.0
    },
    {
        "text": " Si en eso por que quiero 13, ¿eh? ¿Eres el orden de ejecución?",
        "start": 1620.0,
        "end": 1624.0
    },
    {
        "text": " Acabamos a suponer que el usuario va a ingresar lo que le pedimos de 1 a 12.",
        "start": 1625.0,
        "end": 1629.0
    },
    {
        "text": " Tendría que controlar con un y de repente manejar un rango más grande y asegurarte que si o si sea de 1 a 12.",
        "start": 1629.0,
        "end": 1636.0
    },
    {
        "text": " En este ejemplo estamos suponiendo que si le pido de 1 a 12 me ingresa de 1 a 12.",
        "start": 1638.0,
        "end": 1642.0
    },
    {
        "text": " Bien.",
        "start": 1645.0,
        "end": 1646.0
    },
    {
        "text": " ¿Qué más podemos hacer con un enumerado?",
        "start": 1647.0,
        "end": 1649.0
    },
    {
        "text": " Mostrarlo por pantalla.",
        "start": 1650.0,
        "end": 1652.0
    },
    {
        "text": " Definimos otro procedimiento llamado mostrar mes que le pasamos un parámetro de tipo mes y de qué manera se pasó este parámetro acá.",
        "start": 1653.0,
        "end": 1663.0
    },
    {
        "text": " Por valor no por referencia.",
        "start": 1665.0,
        "end": 1667.0
    },
    {
        "text": " Por referencia habría sido si le ponía que cosa.",
        "start": 1667.0,
        "end": 1670.0
    },
    {
        "text": " Bar.",
        "start": 1670.0,
        "end": 1671.0
    },
    {
        "text": " Pero acá está bien no pasarlo por referencia porque no debo pasarlo por referencia.",
        "start": 1671.0,
        "end": 1676.0
    },
    {
        "text": " Porque no lo quiero modificar solamente lo quiero mostrar.",
        "start": 1677.0,
        "end": 1680.0
    },
    {
        "text": " Unicamente debo pasar un parámetro por referencia cuando expresamente deseo modificarlo dentro del procedimiento.",
        "start": 1680.0,
        "end": 1687.0
    },
    {
        "text": " Bueno y acá discutimos qué valor trajo M.",
        "start": 1689.0,
        "end": 1692.0
    },
    {
        "text": " Lo puedo poner en un caíz porque al ser un enumerado es un tipo como.",
        "start": 1693.0,
        "end": 1697.0
    },
    {
        "text": " Ordinal.",
        "start": 1698.0,
        "end": 1699.0
    },
    {
        "text": " Y acá estoy listando todos los posibles valores que puede tomar M.",
        "start": 1699.0,
        "end": 1705.0
    },
    {
        "text": " Entonces si viene por ejemplo abril va a entrar acá y va a mostrar el mensaje en pantalla abril.",
        "start": 1706.0,
        "end": 1713.0
    },
    {
        "text": " O sea los enumerados no se pueden leer directamente con RID y no se pueden mostrar directamente con RID.",
        "start": 1714.0,
        "end": 1721.0
    },
    {
        "text": " Debo hacerlo de esta manera.",
        "start": 1721.0,
        "end": 1723.0
    },
    {
        "text": " ¿Sabes?",
        "start": 1725.0,
        "end": 1726.0
    },
    {
        "text": " ¿Más preguntas de esto?",
        "start": 1728.0,
        "end": 1729.0
    },
    {
        "text": " Bueno y vamos a hablar ahora un poquito de los conjuntos.",
        "start": 1730.0,
        "end": 1735.0
    },
    {
        "text": " Los conjuntos eran tipos que pertenecían a qué categoría.",
        "start": 1736.0,
        "end": 1741.0
    },
    {
        "text": " Estrupturados junto con cuales otros.",
        "start": 1743.0,
        "end": 1746.0
    },
    {
        "text": " Los arreglos que ya los vimos y los record los registros que los vamos a ver ahora en un ratito.",
        "start": 1747.0,
        "end": 1753.0
    },
    {
        "text": " ¿Cuál es la idea?",
        "start": 1755.0,
        "end": 1757.0
    },
    {
        "text": " Nos gustaría poder almacenar un conjunto de valores.",
        "start": 1758.0,
        "end": 1763.0
    },
    {
        "text": " Conjunto en el sentido matemático.",
        "start": 1763.0,
        "end": 1765.0
    },
    {
        "text": " Un conjunto en el mundo de la matemática que es.",
        "start": 1767.0,
        "end": 1769.0
    },
    {
        "text": " Una agrupación de valores.",
        "start": 1770.0,
        "end": 1771.0
    },
    {
        "text": " En donde no hay que cosa.",
        "start": 1773.0,
        "end": 1775.0
    },
    {
        "text": " No hay orden dentro del conjunto y tampoco hay repetidos dentro del conjunto.",
        "start": 1776.0,
        "end": 1781.0
    },
    {
        "text": " Si yo escribo el conjunto 1, 2, 3 es lo mismo que si escribo el conjunto 3, 2, 1.",
        "start": 1782.0,
        "end": 1787.0
    },
    {
        "text": " Por más que yo enumere sus valores en orden diferente son el mismo conjunto.",
        "start": 1788.0,
        "end": 1794.0
    },
    {
        "text": " Entonces queremos poder representar conjuntos de elementos simples.",
        "start": 1797.0,
        "end": 1804.0
    },
    {
        "text": " Desde el punto de vista matemático representa que domal la palabra y represente.",
        "start": 1805.0,
        "end": 1810.0
    },
    {
        "text": " La notación matemática de conjuntos.",
        "start": 1811.0,
        "end": 1814.0
    },
    {
        "text": " No pueden haber repetidos y no hay un orden entre los elementos.",
        "start": 1815.0,
        "end": 1819.0
    },
    {
        "text": " Vamos a ver que para los conjuntos están definidas las operaciones habituales, unión, intersección y diferencia.",
        "start": 1820.0,
        "end": 1826.0
    },
    {
        "text": " Vamos a ver en breve cómo se escriben en Pascal.",
        "start": 1827.0,
        "end": 1829.0
    },
    {
        "text": " Y ojo que un conjunto lo es lo mismo que un arreglo.",
        "start": 1830.0,
        "end": 1833.0
    },
    {
        "text": " En una reglo yo puedo tener valores repetidos.",
        "start": 1834.0,
        "end": 1836.0
    },
    {
        "text": " Si en una reglo importa el orden, si hay un índice.",
        "start": 1837.0,
        "end": 1842.0
    },
    {
        "text": " En el conjunto no, el conjunto es como una bolsa y vos dentro de la bolsa tiraste determinados elementos.",
        "start": 1843.0,
        "end": 1849.0
    },
    {
        "text": " No importa cuál cayó primero, cuál cayó después.",
        "start": 1850.0,
        "end": 1852.0
    },
    {
        "text": " Si pusiste primero el 1 luego el 2 y luego el 3, o primero el 3 luego el 1 después el 2 te quedó el mismo conjunto.",
        "start": 1853.0,
        "end": 1858.0
    },
    {
        "text": " Entonces cómo se definen en Pascal dentro de la sección type, le ponemos un nombre al conjunto y después se utiliza las palabras set-off.",
        "start": 1859.0,
        "end": 1874.0
    },
    {
        "text": " Estamos diciendo que te va a ser un conjunto de elementos del tipo que yo ponga ahí.",
        "start": 1875.0,
        "end": 1883.0
    },
    {
        "text": " Y la restricción de Pascal es que ese tipo debe ser como un tipo ordinal.",
        "start": 1884.0,
        "end": 1889.0
    },
    {
        "text": " Podrías definirte vos un subrango tuyo que no predefinido es ordinal y usarlo acá.",
        "start": 1894.0,
        "end": 1900.0
    },
    {
        "text": " Hay una restricción más que impone Pascal, además de que sea un tipo ordinal y es que la cantidad de elementos del conjunto debe ser menor a 256.",
        "start": 1902.0,
        "end": 1912.0
    },
    {
        "text": " No te deja almacenar más de 250 y seis.",
        "start": 1913.0,
        "end": 1916.0
    },
    {
        "text": " Habría que preguntarle a que inventó el lenguaje porque pusieron esa restricción.",
        "start": 1917.0,
        "end": 1921.0
    },
    {
        "text": " Entonces, conjuntos únicamente de valores que sean ordinales y como mucho de 256 elementos posibles.",
        "start": 1923.0,
        "end": 1931.0
    },
    {
        "text": " Entonces por ejemplo, yo me puedo definir conjuntos como los que están allí.",
        "start": 1934.0,
        "end": 1939.0
    },
    {
        "text": " Ojo que estamos definiendo tipos de datos.",
        "start": 1940.0,
        "end": 1944.0
    },
    {
        "text": " Luego yo me puedo declarar variables que pertenezcan a esos tipos de datos.",
        "start": 1945.0,
        "end": 1950.0
    },
    {
        "text": " Por ejemplo, me podía definir un tipo de datos llamado al facet.",
        "start": 1952.0,
        "end": 1957.0
    },
    {
        "text": " Y al facet es un conjunto de caracteres que pueden ir entre la A y la Z.",
        "start": 1959.0,
        "end": 1965.0
    },
    {
        "text": " Ahora vamos a ver cómo es que armamos una variable de setica.",
        "start": 1966.0,
        "end": 1970.0
    },
    {
        "text": " O me podría definir otro conjunto llamado código y cualquier variable de tipo código va a ser un conjunto de valores que van entre el 1 y el 50.",
        "start": 1971.0,
        "end": 1982.0
    },
    {
        "text": " O sea, ven que ahí estamos usando subrango de enteros y arriba fue subrango de caracteres.",
        "start": 1983.0,
        "end": 1990.0
    },
    {
        "text": " Puede definir un conjunto llamado charset como un conjunto de valores de tipo char que por suerte tiene 256 valores.",
        "start": 1991.0,
        "end": 2002.0
    },
    {
        "text": " Hasta acá pasca lo soporta.",
        "start": 2003.0,
        "end": 2005.0
    },
    {
        "text": " El que no va a soportar va a ser este.",
        "start": 2006.0,
        "end": 2008.0
    },
    {
        "text": " ¿Por qué que pasa con un taller?",
        "start": 2009.0,
        "end": 2011.0
    },
    {
        "text": " Tiene más de 256 elementos posibles.",
        "start": 2012.0,
        "end": 2015.0
    },
    {
        "text": " Este no me lo va a dejar definir.",
        "start": 2016.0,
        "end": 2017.0
    },
    {
        "text": " Ok?",
        "start": 2018.0,
        "end": 2019.0
    },
    {
        "text": " Bien.",
        "start": 2021.0,
        "end": 2022.0
    },
    {
        "text": " Por ejemplo, me defino un tipo de datos llamado dígitos que es un conjunto de valores en el rango de 0 a 9.",
        "start": 2027.0,
        "end": 2037.0
    },
    {
        "text": " Y lo que tenemos acá son objetos de tipo dígitos.",
        "start": 2040.0,
        "end": 2045.0
    },
    {
        "text": " Valores que yo puedo almacenar en una variable de tipo dígitos.",
        "start": 2046.0,
        "end": 2052.0
    },
    {
        "text": " Por ejemplo, vamos a aprender acá.",
        "start": 2053.0,
        "end": 2055.0
    },
    {
        "text": " En la sección de variables de mi programa, yo me podría declarar 3 variables de tipo dígitos.",
        "start": 2055.0,
        "end": 2082.0
    },
    {
        "text": " Cada una de ellas va a representar un conjunto de valores que pueden ir entre 0 a 9.",
        "start": 2086.0,
        "end": 2095.0
    },
    {
        "text": " Luego más adelante en el cuerpo de mi programa, yo podría, por ejemplo, a la variable C1, asignarle el conjunto 0, 2, 4, 6, 8.",
        "start": 2096.0,
        "end": 2113.0
    },
    {
        "text": " C1 es una variable de tipo dígitos.",
        "start": 2116.0,
        "end": 2120.0
    },
    {
        "text": " C1 es un conjunto porque fue declarado como 7.",
        "start": 2121.0,
        "end": 2124.0
    },
    {
        "text": " Y lo que guardo dentro de C1 es el conjunto formado por estos valores.",
        "start": 2125.0,
        "end": 2131.0
    },
    {
        "text": " Si yo hubiera puesto 864.2.0, si lo subiera escrito en distinto orden, igualmente sería el mismo conjunto.",
        "start": 2132.0,
        "end": 2140.0
    },
    {
        "text": " Puedo, por ejemplo, asignarle a C2, el conjunto 1, 3.",
        "start": 2141.0,
        "end": 2153.0
    },
    {
        "text": " O sea que C1 es una variable cuyo valor es el conjunto 0, 2, 4, 6, 8.",
        "start": 2156.0,
        "end": 2163.0
    },
    {
        "text": " C2 es otra variable cuyo valor es el conjunto 1, 3.",
        "start": 2164.0,
        "end": 2169.0
    },
    {
        "text": " Estas son conjuntas.",
        "start": 2171.0,
        "end": 2173.0
    },
    {
        "text": " ¿Se han entendido esto?",
        "start": 2175.0,
        "end": 2176.0
    },
    {
        "text": " Estas son conjuntas. ¿Por qué?",
        "start": 2178.0,
        "end": 2181.0
    },
    {
        "text": " ¿Por qué tanto dentro de C1 como dentro de C2 que me quedaron?",
        "start": 2182.0,
        "end": 2186.0
    },
    {
        "text": " Varios valores juntos que justamente lo que permiten los tipos estructurados.",
        "start": 2187.0,
        "end": 2190.0
    },
    {
        "text": " Y bueno, las operaciones que están definidas para los conjuntos son las siguientes.",
        "start": 2191.0,
        "end": 2202.0
    },
    {
        "text": " Por ejemplo, el operador más aplicado a conjuntos representa la unión de conjuntos.",
        "start": 2203.0,
        "end": 2209.0
    },
    {
        "text": " El operador por no es multiplicación.",
        "start": 2210.0,
        "end": 2213.0
    },
    {
        "text": " Es multiplicación si se lo aplico valores numéricos.",
        "start": 2214.0,
        "end": 2217.0
    },
    {
        "text": " Pero si se lo aplico a conjuntos, el por representa la intersección.",
        "start": 2218.0,
        "end": 2221.0
    },
    {
        "text": " El menos la diferencia.",
        "start": 2222.0,
        "end": 2224.0
    },
    {
        "text": " Después tenemos estos tres operadores relacionales definidos, comparación por igualdad, por desigualdad y por inclusión.",
        "start": 2225.0,
        "end": 2232.0
    },
    {
        "text": " Y después hay un operador especial que es el operador IN que me permite chequear si un valor dado pertenece o no al conjunto.",
        "start": 2233.0,
        "end": 2241.0
    },
    {
        "text": " Vamos a ver por arriba si quieren profundizar en conjuntos en el tema set lo tienen en el entaje en el libro.",
        "start": 2242.0,
        "end": 2249.0
    },
    {
        "text": " Nosotros lo vamos a ver poco y más bien por arriba.",
        "start": 2250.0,
        "end": 2253.0
    },
    {
        "text": " Y no vamos a hacer gran uso de ellos. Puede que aparezca algo en algún ejercicio, pero no es tema central del curso.",
        "start": 2254.0,
        "end": 2259.0
    },
    {
        "text": " ¿Sí?",
        "start": 2262.0,
        "end": 2263.0
    },
    {
        "text": " El instrucción entre esa tabla de C2 o F4.",
        "start": 2263.0,
        "end": 2268.0
    },
    {
        "text": " Correcto. Estos cuatro devuelven como resultado en bulián.",
        "start": 2268.0,
        "end": 2272.0
    },
    {
        "text": " Sí.",
        "start": 2273.0,
        "end": 2274.0
    },
    {
        "text": " Si ha sido sobre el designo y conjunto son como dos, se sobrecribe o...",
        "start": 2275.0,
        "end": 2280.0
    },
    {
        "text": " Se sobrecribe. Si vos querés agregarle un valor, tienes que usar más para hacer unión.",
        "start": 2281.0,
        "end": 2285.0
    },
    {
        "text": " De hecho lo vamos a ver ahora. Allá.",
        "start": 2286.0,
        "end": 2287.0
    },
    {
        "text": " ¿La desigualdad?",
        "start": 2289.0,
        "end": 2290.0
    },
    {
        "text": " Sí. La desigualdad es vendría ser inclusión estricta.",
        "start": 2291.0,
        "end": 2293.0
    },
    {
        "text": " Y este vendría ser la inclusión amplia entre conjuntos.",
        "start": 2294.0,
        "end": 2297.0
    },
    {
        "text": " Por ejemplo yo puedo hacer esto.",
        "start": 2300.0,
        "end": 2301.0
    },
    {
        "text": " Hace tres, asignarle C1 más C2. Este más significa unión porque C1 y C2 son de tipo conjunto.",
        "start": 2303.0,
        "end": 2316.0
    },
    {
        "text": " El resultado de esta operación va a ser un nuevo conjunto con que valores.",
        "start": 2317.0,
        "end": 2323.0
    },
    {
        "text": " 0, 2, 4, 6, 8, 1 y 3.",
        "start": 2324.0,
        "end": 2327.0
    },
    {
        "text": " Literalmente la unión entre dos conjuntos.",
        "start": 2328.0,
        "end": 2330.0
    },
    {
        "text": " Si hubiera hecho el menos me habría dado la intersección que en este caso particular que sería.",
        "start": 2331.0,
        "end": 2337.0
    },
    {
        "text": " El conjunto vacío.",
        "start": 2339.0,
        "end": 2340.0
    },
    {
        "text": " No, intersección.",
        "start": 2341.0,
        "end": 2342.0
    },
    {
        "text": " Perdón, intersección a este riesgo. Sí, menos es diferencia.",
        "start": 2343.0,
        "end": 2345.0
    },
    {
        "text": " La intersección que me habría dado.",
        "start": 2346.0,
        "end": 2347.0
    },
    {
        "text": " Basío, corchete que abre, corchete que se arra.",
        "start": 2348.0,
        "end": 2350.0
    },
    {
        "text": " O sea, a todos los efectos son las mismas operaciones de la algebra de conjuntos.",
        "start": 2351.0,
        "end": 2355.0
    },
    {
        "text": " La diferencia es todos los elementos que están en el primer conjunto y no están en el segundo.",
        "start": 2356.0,
        "end": 2361.0
    },
    {
        "text": " Si lo dibujabas con los diagramas de vénera la media alumna de la izquierda.",
        "start": 2363.0,
        "end": 2366.0
    },
    {
        "text": " Por ejemplo, el operador IN.",
        "start": 2367.0,
        "end": 2370.0
    },
    {
        "text": " Yo podría preguntar esto.",
        "start": 2371.0,
        "end": 2372.0
    },
    {
        "text": " IF.",
        "start": 2373.0,
        "end": 2374.0
    },
    {
        "text": " Tres.",
        "start": 2376.0,
        "end": 2377.0
    },
    {
        "text": " IN.",
        "start": 2378.0,
        "end": 2379.0
    },
    {
        "text": " C3.",
        "start": 2380.0,
        "end": 2381.0
    },
    {
        "text": " Y lo que hace esta expresión buliana es verificar si el tres pertenece al conjunto C3.",
        "start": 2386.0,
        "end": 2394.0
    },
    {
        "text": " Si pertenece le pondré un cartelito indicando que el valor 3 pertenece al conjunto.",
        "start": 2395.0,
        "end": 2402.0
    },
    {
        "text": " Y si no le pondré un cartel que día que no.",
        "start": 2406.0,
        "end": 2408.0
    },
    {
        "text": " O sea, que hemos agregado a nuestra batería de tipos de datos los enumerados, que son un caso particular de tipo ordinal, y acabamos de agregar los conjuntos.",
        "start": 2412.0,
        "end": 2421.0
    },
    {
        "text": " Y ahora un ratito vamos a agregar los registros y con eso tenemos toda la batería completa.",
        "start": 2422.0,
        "end": 2427.0
    },
    {
        "text": " Más preguntas de Z.",
        "start": 2431.0,
        "end": 2432.0
    },
    {
        "text": " Bien.",
        "start": 2436.0,
        "end": 2437.0
    },
    {
        "text": " Vamos a enchar un poquito el práctico.",
        "start": 2438.0,
        "end": 2439.0
    },
    {
        "text": " Si.",
        "start": 2442.0,
        "end": 2443.0
    },
    {
        "text": " Aplicarse a unión.",
        "start": 2444.0,
        "end": 2446.0
    },
    {
        "text": " Podré ejemplo, podrías poner C1 más y entre colchetes el nuevo elemento que le queréis agregar.",
        "start": 2447.0,
        "end": 2454.0
    },
    {
        "text": " O sea, tenés que armar un conjunto unitario y aplicar unión.",
        "start": 2456.0,
        "end": 2459.0
    },
    {
        "text": " Bien.",
        "start": 2460.0,
        "end": 2461.0
    },
    {
        "text": " Bueno, práctico de estas semanas el práctico 10.",
        "start": 2465.0,
        "end": 2468.0
    },
    {
        "text": " Los primeros ejercicios juegan un poquito con el tema de tipos ordinales y tipos enumerados en particular, y a medida que avanza aparecen más ejercicios sobre registros.",
        "start": 2469.0,
        "end": 2483.0
    },
    {
        "text": " Creo que alguno de los conjuntos también hay.",
        "start": 2484.0,
        "end": 2486.0
    },
    {
        "text": " Bueno, vamos a mirar un poquito el ejercicio 3.",
        "start": 2488.0,
        "end": 2490.0
    },
    {
        "text": " Ya vería cómo tenemos un número de múñedos muy bien.",
        "start": 2491.0,
        "end": 2493.0
    },
    {
        "text": " Recién acabamos de salir de la primera tarea, todavía no estamos pensando en la segunda. Vamos a disfrutar del tiempo de tranquilidad en el medio.",
        "start": 2494.0,
        "end": 2500.0
    },
    {
        "text": " A ver, vamos a ver registros, después vamos, bueno vamos la semana que viene, vamos a ver una cosa que se llama Reglo con Toppe, después vienen registros con variantes,",
        "start": 2502.0,
        "end": 2510.0
    },
    {
        "text": " después vienen punteros y listas y recién después de eso viene la segunda tarea. O sea, nos falta ver unas cuantas cosas todavía.",
        "start": 2510.0,
        "end": 2516.0
    },
    {
        "text": " Bueno, tenemos acá un programita, y nos dan cuatro firmaciones y tenemos que ver si son correctas o no los son.",
        "start": 2519.0,
        "end": 2528.0
    },
    {
        "text": " Bueno, programa de nombre bueno, que define un tipo llamado materia y qué clase de tipo es.",
        "start": 2531.0,
        "end": 2538.0
    },
    {
        "text": " Es un enumerado. O sea, que toda variable de tipo materia va a poder tomar uno de esos cinco valores posibles.",
        "start": 2540.0,
        "end": 2549.0
    },
    {
        "text": " Agrandamos un poquito.",
        "start": 2550.0,
        "end": 2551.0
    },
    {
        "text": " Ahí, bien.",
        "start": 2555.0,
        "end": 2556.0
    },
    {
        "text": " Bueno, tenemos declaradas dos variables de tipo materia, a aliasignamos matemáticas y a velasignamos computación.",
        "start": 2559.0,
        "end": 2567.0
    },
    {
        "text": " Estos dos son valores válidos del tipo numerado, por lo tanto está bien asignarse los sabariables que son del tipo numerado.",
        "start": 2567.0,
        "end": 2576.0
    },
    {
        "text": " Y después viene una comparación con unif, si a es mayor que ve, mostramos magnífico y si no mostramos excelente.",
        "start": 2579.0,
        "end": 2588.0
    },
    {
        "text": " No le busque en sentido, no importa, un programa.",
        "start": 2589.0,
        "end": 2592.0
    },
    {
        "text": " En fin, vamos a las afirmaciones estas. La primera, en la proposición if, a y b, no se pueden comparar porque no son números.",
        "start": 2593.0,
        "end": 2608.0
    },
    {
        "text": " Correcta o incorrecta.",
        "start": 2610.0,
        "end": 2611.0
    },
    {
        "text": " Si o no. Es incorrecta, porque.",
        "start": 2616.0,
        "end": 2621.0
    },
    {
        "text": " Los valores de tipos ordinales se pueden comparar con este operador relacional.",
        "start": 2623.0,
        "end": 2628.0
    },
    {
        "text": " Si dijimos que los tipos ordinales tenían definidos los operadores de comparación relacionales.",
        "start": 2629.0,
        "end": 2634.0
    },
    {
        "text": " O sea, que a y b se pueden comparar porque son valores de un mismo tipo ordinal.",
        "start": 2635.0,
        "end": 2641.0
    },
    {
        "text": " Perfectamente se pueden comparar.",
        "start": 2642.0,
        "end": 2644.0
    },
    {
        "text": " O sea, que la afirmación a es falsa, es incorrecta.",
        "start": 2646.0,
        "end": 2650.0
    },
    {
        "text": " B, el programa exhibirá el cartel magnífico.",
        "start": 2653.0,
        "end": 2657.0
    },
    {
        "text": " falsa, a ver, a, es mayor que ve como hacemos para responder esta pregunta.",
        "start": 2660.0,
        "end": 2666.0
    },
    {
        "text": " A es matemáticas y b es computación. Veamos en el enumerado, cuál aparece primero.",
        "start": 2667.0,
        "end": 2673.0
    },
    {
        "text": " Matemáticas está antes que computación. O sea, que en la codificación interna del tipo ordinal, cuál es menor.",
        "start": 2674.0,
        "end": 2681.0
    },
    {
        "text": " Matemáticas. O sea, que no es cierto que matemáticas sea mayor que computación.",
        "start": 2683.0,
        "end": 2688.0
    },
    {
        "text": " Por lo tanto va a venir a Lells y va a desplegar excelente.",
        "start": 2689.0,
        "end": 2693.0
    },
    {
        "text": " Que justamente la afirmación C y que en el PDF ya estaba atilado.",
        "start": 2695.0,
        "end": 2699.0
    },
    {
        "text": " Importa la reflexión sirve.",
        "start": 2700.0,
        "end": 2702.0
    },
    {
        "text": " La D, que ya nos dimos cuenta que es incorrecta, dice que la proposición X provocará un error de ejecución.",
        "start": 2705.0,
        "end": 2711.0
    },
    {
        "text": " Bueno, no provocará una error de ejecución, porque no.",
        "start": 2712.0,
        "end": 2715.0
    },
    {
        "text": " Porque se pueden comparar y se pueden comparar, porque son valores de un mismo tipo ordinal.",
        "start": 2716.0,
        "end": 2723.0
    },
    {
        "text": " Sabien?",
        "start": 2725.0,
        "end": 2726.0
    },
    {
        "text": " Bueno, desde el 1 hasta como el 4 o 5 tienen un montón de ejercicios para entrar en calor y entretenerse con los tipos ordinales.",
        "start": 2727.0,
        "end": 2736.0
    },
    {
        "text": " Sabien, los enumerados, jugaron un poquito más con los subrangos, pero más que nada los enumerados.",
        "start": 2737.0,
        "end": 2744.0
    },
    {
        "text": " Bueno, más pregunta de enumerados.",
        "start": 2746.0,
        "end": 2748.0
    },
    {
        "text": " Seguimos con el teoría y que pasamos a los registros ahora.",
        "start": 2750.0,
        "end": 2753.0
    },
    {
        "text": " Bueno,",
        "start": 2767.0,
        "end": 2771.0
    },
    {
        "text": " empieza hablando un poquito de la clasificación de tipos, lo voy a pasar medio rápido, porque es lo que ya hicimos al comienzo.",
        "start": 2774.0,
        "end": 2780.0
    },
    {
        "text": " Están los elementales y están los estructurados.",
        "start": 2781.0,
        "end": 2785.0
    },
    {
        "text": " Dentro de los elementales están los ordinales y los otros, es decir, los no ordinales que el único que hay allí es al real.",
        "start": 2786.0,
        "end": 2795.0
    },
    {
        "text": " Y los ordinales pueden ser inteschar, búlian, subrangos y enumerados.",
        "start": 2797.0,
        "end": 2801.0
    },
    {
        "text": " De todos ellos, los primeros tres ya son predefinidos, los últimos dos podemos definirme los otros.",
        "start": 2802.0,
        "end": 2808.0
    },
    {
        "text": " Y luego estaban los estructurados, los arreglos que ya los vimos, los conjuntos que los acabamos de ver y nos faltan por ver los registros.",
        "start": 2810.0,
        "end": 2817.0
    },
    {
        "text": " Primero, por ser un tipo estructurado que van a permitir los registros.",
        "start": 2821.0,
        "end": 2825.0
    },
    {
        "text": " Al masenar juntos varios valores dentro de una misma variable.",
        "start": 2827.0,
        "end": 2832.0
    },
    {
        "text": " Que eso es en general lo que permiten los tipos estructurados.",
        "start": 2833.0,
        "end": 2837.0
    },
    {
        "text": " Los arreglos son secuencias homogéneas de tamaño fijo.",
        "start": 2840.0,
        "end": 2845.0
    },
    {
        "text": " Homogéneas quiere decir que todos los elementos deben ser todos como del mismo tipo.",
        "start": 2846.0,
        "end": 2853.0
    },
    {
        "text": " Yo tengo un arreglo todo de enteros o tengo un arreglo todo de búlianos o tengo un arreglo todo de caracteres.",
        "start": 2854.0,
        "end": 2860.0
    },
    {
        "text": " No puedo mezclar valores de tipos diferentes en un mismo arreglo.",
        "start": 2861.0,
        "end": 2865.0
    },
    {
        "text": " Los valores de las celdas estaban obligados a ser de tipos ordinales.",
        "start": 2867.0,
        "end": 2871.0
    },
    {
        "text": " No, los arreglos podrían ser de cualquier tipo, ordinal o no ordinal.",
        "start": 2872.0,
        "end": 2876.0
    },
    {
        "text": " Yo podía tener un arreglo de reales o podía tener un arreglo de arreglos.",
        "start": 2877.0,
        "end": 2882.0
    },
    {
        "text": " Y eso tenía un nombre como lo llamábamos en una matriz arreglos y dimensionales.",
        "start": 2883.0,
        "end": 2888.0
    },
    {
        "text": " O sea que el tipo de datos de lo que van las celdas de arreglo puede ser cualquiera.",
        "start": 2890.0,
        "end": 2894.0
    },
    {
        "text": " La única restricción es que tiene que ser el mismo tipo para todas las celdas.",
        "start": 2895.0,
        "end": 2898.0
    },
    {
        "text": " El orden es relevante, hay un primer elemento, un segundo, un tercero y puede admitir valores repetidos.",
        "start": 2900.0,
        "end": 2906.0
    },
    {
        "text": " Yo puedo tener en la celdatriz un 7 y en la celda 9 o otro 7.",
        "start": 2908.0,
        "end": 2911.0
    },
    {
        "text": " Los conjuntos que los acabamos de ver son conjuntos en el sentido matemático.",
        "start": 2914.0,
        "end": 2919.0
    },
    {
        "text": " No hay un orden entre los elementos y no hay repetidos.",
        "start": 2920.0,
        "end": 2923.0
    },
    {
        "text": " El tamaño es variable pero acotado, había un máximo de valores posibles.",
        "start": 2924.0,
        "end": 2928.0
    },
    {
        "text": " Fíjense que dice que es variable porque por ejemplo, c1 y c2, los 2 son conjuntos del mismo tipo.",
        "start": 2930.0,
        "end": 2938.0
    },
    {
        "text": " Sin embargo, uno tiene 5 valores y el otro tiene 2.",
        "start": 2939.0,
        "end": 2941.0
    },
    {
        "text": " O sea que yo puedo tener 2 conjuntos diferentes de valores del mismo tipo pero con cantidades distintas de elementos.",
        "start": 2943.0,
        "end": 2950.0
    },
    {
        "text": " Ahora si yo me declaraba 2 arreglos del mismo tipo, ¿qué pasaba con el tamaño de esos 2 arreglos?",
        "start": 2951.0,
        "end": 2956.0
    },
    {
        "text": " Tenía que ser iguales porque en la propia definición del tipo ya quedaba establecida la cantidad de celdas.",
        "start": 2957.0,
        "end": 2963.0
    },
    {
        "text": " Bueno, ¿qué es lo que vienen a cubrir los registros?",
        "start": 2964.0,
        "end": 2969.0
    },
    {
        "text": " Nos van a permitir definir lo que vamos a llamar una colección heterogénia y ordenada de datos.",
        "start": 2970.0,
        "end": 2976.0
    },
    {
        "text": " Es decir, dentro de un registro yo voy a poder guardar valores que son no necesariamente del mismo tipo.",
        "start": 2977.0,
        "end": 2983.0
    },
    {
        "text": " Puedo mezclar juntos valores de distinto tipo.",
        "start": 2984.0,
        "end": 2987.0
    },
    {
        "text": " Vamos a ver que los elementos también tienen un orden pero que a diferencia de los arreglos no tienen un índice sino que se van a llamar campos o componentes y cada componente va a estar identificada por un nombre.",
        "start": 2988.0,
        "end": 3004.0
    },
    {
        "text": " También se les dice tuplas, o sea, a los valores de un tipo registro se los conoce muchas veces como tuplas.",
        "start": 3007.0,
        "end": 3014.0
    },
    {
        "text": " Y al igual que los arreglos tienen un tamaño fijo.",
        "start": 3015.0,
        "end": 3019.0
    },
    {
        "text": " Entonces, ¿cuál es la idea? Por ejemplo, imaginemos que nosotros queremos guardar dentro de una misma variable los siguientes datos de un estudiante.",
        "start": 3023.0,
        "end": 3034.0
    },
    {
        "text": " Su cédula, su nombre, su dirección y su teléfono.",
        "start": 3035.0,
        "end": 3039.0
    },
    {
        "text": " Quiero poder guardar juntas esas cuatro cosas en una misma variable.",
        "start": 3040.0,
        "end": 3044.0
    },
    {
        "text": " No las puedo guardar en una reglo, ¿por qué?",
        "start": 3045.0,
        "end": 3048.0
    },
    {
        "text": " Porque no son todas el mismo tipo, tienen diferente tipo.",
        "start": 3049.0,
        "end": 3052.0
    },
    {
        "text": " Tampoco las podría guardar en un conjunto, ¿por qué?",
        "start": 3053.0,
        "end": 3056.0
    },
    {
        "text": " Porque no todos son valores ordinales.",
        "start": 3057.0,
        "end": 3060.0
    },
    {
        "text": " Entonces, la estructura adecuada es el registro.",
        "start": 3061.0,
        "end": 3066.0
    },
    {
        "text": " Los registros nos permiten representar objetos de la realidad,",
        "start": 3068.0,
        "end": 3072.0
    },
    {
        "text": " mediante lo que vamos a llamar estructuras de datos, o sea, agrupar juntos valores que representan algo de una cierta realidad y que pueden ser de distinto tipo.",
        "start": 3073.0,
        "end": 3084.0
    },
    {
        "text": " En Pascal, la estructura más utilizada es el record.",
        "start": 3085.0,
        "end": 3090.0
    },
    {
        "text": " Más adelante van a venir las listas, pero por ahora tenemos el record.",
        "start": 3090.0,
        "end": 3094.0
    },
    {
        "text": " Y un record es una tupla de datos de diferente tipo, cada uno de los cuales se accede mediante un nombre de campo de nuevo.",
        "start": 3095.0,
        "end": 3102.0
    },
    {
        "text": " No tengo índices como en los arreglos.",
        "start": 3103.0,
        "end": 3105.0
    },
    {
        "text": " Tengo un campo llamado CI de tipo entero.",
        "start": 3106.0,
        "end": 3109.0
    },
    {
        "text": " Tengo un campo llamado nombre de tipo cadena de caracteres, dirección, teléfono.",
        "start": 3110.0,
        "end": 3115.0
    },
    {
        "text": " Entonces, cuando yo defino un tipo registro, yo voy a definir cómo se van a llamar cada uno de sus campos, cada una de sus componentes y de qué tipo van a ser.",
        "start": 3117.0,
        "end": 3127.0
    },
    {
        "text": " Pero sí, ahí no es un punto, hay de tipo chari, hay de tipo de fila.",
        "start": 3129.0,
        "end": 3136.0
    },
    {
        "text": " Claro, es que cuando yo definas los tipos de datos del programa, probablemente me definí de primero un arreglo de caracteres para guardarme los caracteres del nombre.",
        "start": 3137.0,
        "end": 3146.0
    },
    {
        "text": " A su vez dirección, probablemente yo lo puedo definir como otro tipo record formado por una cadena de caracteres de un número.",
        "start": 3153.0,
        "end": 3159.0
    },
    {
        "text": " Recuerden que ustedes pueden definir varios tipos de datos dentro de un mismo programa.",
        "start": 3160.0,
        "end": 3164.0
    },
    {
        "text": " Pero, pero van a ir a la dirección, puede haber, o sea, 7, 8 y después, o sea, 7, 8, 3, 3, 4 y después, o sea, ¿qué es el de los estudiantes?",
        "start": 3167.0,
        "end": 3175.0
    },
    {
        "text": " Un estudiante cuantos datos tiene.",
        "start": 3175.0,
        "end": 3177.0
    },
    {
        "text": " Cédula, nombre, dirección y teléfono. Después nos preocupamos de definir el tipo para la dirección.",
        "start": 3179.0,
        "end": 3183.0
    },
    {
        "text": " En realidad, es fácil lo puedes definir como un arreglo de caracteres.",
        "start": 3185.0,
        "end": 3188.0
    },
    {
        "text": " Lo importante es que un estudiante va a tener cuatro componentes bien identificadas.",
        "start": 3190.0,
        "end": 3194.0
    },
    {
        "text": " Cada una de ellas a su vez va a tener su propio tipo de datos, que puede hacer un tipo simple u otro tipo estructurado.",
        "start": 3195.0,
        "end": 3200.0
    },
    {
        "text": " Sí.",
        "start": 3201.0,
        "end": 3202.0
    },
    {
        "text": " No, si hay un orden, en el sentido de que primero definís la cédula, luego el nombre, luego la dirección y luego el teléfono.",
        "start": 3208.0,
        "end": 3215.0
    },
    {
        "text": " Cuando se los almacena, internamente en memoria los almacenas en ese orden.",
        "start": 3216.0,
        "end": 3219.0
    },
    {
        "text": " Pero para accederlos, vos vas a referirte al nombre de la componente.",
        "start": 3220.0,
        "end": 3224.0
    },
    {
        "text": " Ahora lo vamos a ver.",
        "start": 3226.0,
        "end": 3227.0
    },
    {
        "text": " ¿Más preguntas?",
        "start": 3230.0,
        "end": 3231.0
    },
    {
        "text": " Bien.",
        "start": 3233.0,
        "end": 3234.0
    },
    {
        "text": " Aquí tenemos la sintaxis para definir un tipo registro.",
        "start": 3235.0,
        "end": 3239.0
    },
    {
        "text": " De nuevo, es un tipo de datos definido por nosotros, definido por el programador.",
        "start": 3240.0,
        "end": 3245.0
    },
    {
        "text": " Se hace bajo la sección Type.",
        "start": 3246.0,
        "end": 3248.0
    },
    {
        "text": " Le damos un nombre al tipo de datos y después se pone una nueva palabra reservada que es Record.",
        "start": 3249.0,
        "end": 3256.0
    },
    {
        "text": " En cada una de estas líneas, estamos definiendo uno de los campos del registro.",
        "start": 3258.0,
        "end": 3263.0
    },
    {
        "text": " Y finaliza con End y punto y coma.",
        "start": 3264.0,
        "end": 3266.0
    },
    {
        "text": " Cada campo va a tener un nombre y va a tener un tipo.",
        "start": 3268.0,
        "end": 3272.0
    },
    {
        "text": " O sea, los campos se declaran siguiendo la misma sintaxis que se usa para declarar variables.",
        "start": 3273.0,
        "end": 3278.0
    },
    {
        "text": " Entonces, por ejemplo, acá tenemos el tipo de datos estudiante.",
        "start": 3282.0,
        "end": 3288.0
    },
    {
        "text": " Vamos a mirar primero estudiante y después vemos los anteriores.",
        "start": 3290.0,
        "end": 3292.0
    },
    {
        "text": " Un estudiante va a ser un registro que va a tener cuatro campos, una cédula, un nombre, un teléfono y una dirección.",
        "start": 3293.0,
        "end": 3303.0
    },
    {
        "text": " Y cada uno de estos a su vez va a tener su propio tipo de datos.",
        "start": 3305.0,
        "end": 3311.0
    },
    {
        "text": " Puede llegar a pasar que vos tengas en un registro dos campos distintos del mismo tipo.",
        "start": 3313.0,
        "end": 3317.0
    },
    {
        "text": " O puede pasar que sean todos de tipos distintos. Eso depende de la realidad del problema en la que estés.",
        "start": 3317.0,
        "end": 3322.0
    },
    {
        "text": " Para este ejemplo, el tipo para la cédula se definió acá arriba.",
        "start": 3323.0,
        "end": 3328.0
    },
    {
        "text": " Cédula como un arreglo de que?",
        "start": 3329.0,
        "end": 3331.0
    },
    {
        "text": " De dijitos entre ser y nueve.",
        "start": 3332.0,
        "end": 3334.0
    },
    {
        "text": " O sea, que la cédula de un alumno va a ser un arreglo de dijitos.",
        "start": 3335.0,
        "end": 3340.0
    },
    {
        "text": " La última vez que es el tipo de chánero se ha indirección de que...",
        "start": 3341.0,
        "end": 3344.0
    },
    {
        "text": " No llegues, estoy todavía con la cédula.",
        "start": 3345.0,
        "end": 3347.0
    },
    {
        "text": " No me tiembro.",
        "start": 3348.0,
        "end": 3349.0
    },
    {
        "text": " Vamos al nombre.",
        "start": 3350.0,
        "end": 3351.0
    },
    {
        "text": " El nombre se definió como un arreglo de 45 caracteres.",
        "start": 3352.0,
        "end": 3356.0
    },
    {
        "text": " Es que haya espacio suficiente para guardar los caracteres del nombre.",
        "start": 3357.0,
        "end": 3360.0
    },
    {
        "text": " Imagínense los nombres de los actores de las telenovelas heteroméricanas, por ejemplo.",
        "start": 3362.0,
        "end": 3366.0
    },
    {
        "text": " El teléfono se definió mediante un arreglo de siete dijitos entre ser y nueve.",
        "start": 3367.0,
        "end": 3375.0
    },
    {
        "text": " Y ahora sí, la dirección es otro arreglo de caracteres.",
        "start": 3376.0,
        "end": 3379.0
    },
    {
        "text": " Pero también incluso un número de...",
        "start": 3381.0,
        "end": 3383.0
    },
    {
        "text": " Pero ¿qué pasa por ejemplo con esto?",
        "start": 3384.0,
        "end": 3386.0
    },
    {
        "text": " Es un caracter.",
        "start": 3388.0,
        "end": 3389.0
    },
    {
        "text": " Es por eso, o sea, la dirección se modeló mediante un arreglo de caracteres.",
        "start": 3390.0,
        "end": 3394.0
    },
    {
        "text": " Entonces, si yo convino arreglos con registros, con conjuntos, con toda la batería de tipos de datos que nosotros vimos,",
        "start": 3395.0,
        "end": 3405.0
    },
    {
        "text": " eso nos expande el universo de posibilidades de cosas que podemos representar dentro de un programa.",
        "start": 3406.0,
        "end": 3411.0
    },
    {
        "text": " Esto es un estudiante solo.",
        "start": 3413.0,
        "end": 3416.0
    },
    {
        "text": " Yo más abajo luego me podría definir, por ejemplo, un arreglo de estudiantes.",
        "start": 3417.0,
        "end": 3422.0
    },
    {
        "text": " Entonces, ahí guardamos los datos de todos los estudiantes de la clase.",
        "start": 3424.0,
        "end": 3427.0
    },
    {
        "text": " O sea, los tipos de datos se pueden empezar a combinar entre sí para...",
        "start": 3428.0,
        "end": 3432.0
    },
    {
        "text": " ... bueno, procesar la información de la manera que nos interese hacerlo.",
        "start": 3433.0,
        "end": 3436.0
    },
    {
        "text": " No tiene por qué ser una cosa tan grande, puede ser algo chiquito un record.",
        "start": 3442.0,
        "end": 3445.0
    },
    {
        "text": " Podemos usar un record para representar un punto del plano con coordenadas cartesianas.",
        "start": 3446.0,
        "end": 3451.0
    },
    {
        "text": " ¿Sí?",
        "start": 3452.0,
        "end": 3453.0
    },
    {
        "text": " Donde un punto es un registro que tiene dos campos, la coordenada X y la coordenada Y ambas de tipo real.",
        "start": 3454.0,
        "end": 3460.0
    },
    {
        "text": " Fíjense que no es obligatorio que todos los campos sean de distintos tipos,",
        "start": 3462.0,
        "end": 3465.0
    },
    {
        "text": " por estenar campos diferentes que sean del mismo tipo.",
        "start": 3466.0,
        "end": 3468.0
    },
    {
        "text": " Como pasa acá con coordenada X y coordenada Y.",
        "start": 3469.0,
        "end": 3471.0
    },
    {
        "text": " Entonces, yo uso un record para representar un punto del plano.",
        "start": 3472.0,
        "end": 3475.0
    },
    {
        "text": " Las aplicaciones son múltiples.",
        "start": 3476.0,
        "end": 3479.0
    },
    {
        "text": " Por ejemplo, podríamos querer representar un número racional.",
        "start": 3481.0,
        "end": 3485.0
    },
    {
        "text": " O sea, número racional en el sentido de numerador y denominador no me interesa hacer la división,",
        "start": 3487.0,
        "end": 3492.0
    },
    {
        "text": " me interesa dejarlo expresado como una fracción.",
        "start": 3493.0,
        "end": 3494.0
    },
    {
        "text": " Eso también se puede modelar mediante un record.",
        "start": 3497.0,
        "end": 3499.0
    },
    {
        "text": " Un record con tres campos, el signo puede ser positivo o negativo,",
        "start": 3500.0,
        "end": 3506.0
    },
    {
        "text": " el valor del numerador y el valor del denominador.",
        "start": 3507.0,
        "end": 3510.0
    },
    {
        "text": " Y antes me definí otros tres tipos de datos más, un tipo para el signo y esto es que cosa.",
        "start": 3512.0,
        "end": 3518.0
    },
    {
        "text": " Un enumerado, los valores posibles son más y menos.",
        "start": 3520.0,
        "end": 3522.0
    },
    {
        "text": " El tipo natural que es el subrango de 0 a max sin y el tipo positivo que es el subrango de 0 a max sin,",
        "start": 3523.0,
        "end": 3528.0
    },
    {
        "text": " porque esta distinción entre natural y positivo, ¿qué pasa con el denominador?",
        "start": 3529.0,
        "end": 3534.0
    },
    {
        "text": " No puede ser ser, entonces ya en la propia declaración de tipo lo estoy contemplando.",
        "start": 3535.0,
        "end": 3540.0
    },
    {
        "text": " Entonces, un número racional también se puede representarme mediante un record.",
        "start": 3542.0,
        "end": 3547.0
    },
    {
        "text": " ¿Sí?",
        "start": 3549.0,
        "end": 3550.0
    },
    {
        "text": " Sí.",
        "start": 3552.0,
        "end": 3553.0
    },
    {
        "text": " Vos cuando usas un tipo de datos tiene que haber sido definido antes.",
        "start": 3559.0,
        "end": 3564.0
    },
    {
        "text": " O sea, siempre que vos da la referencia a otro tipo de datos definido por ti,",
        "start": 3567.0,
        "end": 3571.0
    },
    {
        "text": " tiene que haber sido definido con anterioridad.",
        "start": 3572.0,
        "end": 3573.0
    },
    {
        "text": " Exacto.",
        "start": 3576.0,
        "end": 3577.0
    },
    {
        "text": " ¿Sabí en?",
        "start": 3578.0,
        "end": 3579.0
    },
    {
        "text": " Y de nuevo, uno dentro de un programa puede definir varios tipos de datos.",
        "start": 3580.0,
        "end": 3582.0
    },
    {
        "text": " Algunos tipos de datos luego se van a usar en la construcción de otros tipos de datos estructurados.",
        "start": 3583.0,
        "end": 3589.0
    },
    {
        "text": " ¿Sí?",
        "start": 3592.0,
        "end": 3593.0
    },
    {
        "text": " Vaya a animar imaginándose la segunda tarea.",
        "start": 3593.0,
        "end": 3595.0
    },
    {
        "text": " Bien.",
        "start": 3598.0,
        "end": 3599.0
    },
    {
        "text": " Bueno, ¿qué tenemos acá?",
        "start": 3601.0,
        "end": 3603.0
    },
    {
        "text": " ¿Qué es esto?",
        "start": 3608.0,
        "end": 3609.0
    },
    {
        "text": " Una variable de tipo racional.",
        "start": 3610.0,
        "end": 3614.0
    },
    {
        "text": " Borro acá.",
        "start": 3616.0,
        "end": 3617.0
    },
    {
        "text": " Tenemos acá nuestra variable Q de tipo racional.",
        "start": 3624.0,
        "end": 3629.0
    },
    {
        "text": " Por ser de tipo racional, ¿cuántos campos tiene?",
        "start": 3631.0,
        "end": 3636.0
    },
    {
        "text": " 3.",
        "start": 3637.0,
        "end": 3638.0
    },
    {
        "text": " El signo, el numerador y el denominador.",
        "start": 3638.0,
        "end": 3640.0
    },
    {
        "text": " O sea, si yo dibujar a Q en memoria,",
        "start": 3643.0,
        "end": 3645.0
    },
    {
        "text": " podríamos imaginarnos que Q es como una ficha que tiene tres lugares.",
        "start": 3646.0,
        "end": 3651.0
    },
    {
        "text": " Sí, todo esto es la variable Q.",
        "start": 3653.0,
        "end": 3658.0
    },
    {
        "text": " El primer campo se llama más.",
        "start": 3660.0,
        "end": 3663.0
    },
    {
        "text": " El segundo campo se llama numerador y el tercero es el denominador.",
        "start": 3664.0,
        "end": 3669.0
    },
    {
        "text": " El primero es, perdón, signo.",
        "start": 3671.0,
        "end": 3674.0
    },
    {
        "text": " Sí, más es un valor posible que puede tomar el signo. Gracias.",
        "start": 3674.0,
        "end": 3677.0
    },
    {
        "text": " Todo esto es la variable Q.",
        "start": 3680.0,
        "end": 3683.0
    },
    {
        "text": " Si yo luego me declarar una variable R de tipo racional,",
        "start": 3684.0,
        "end": 3686.0
    },
    {
        "text": " tendría otro espacio en memoria llamado R y también de video.",
        "start": 3686.0,
        "end": 3691.0
    },
    {
        "text": " Los mismos tres campos.",
        "start": 3691.0,
        "end": 3694.0
    },
    {
        "text": " Ahora bien, dada mi variable de tipo racional,",
        "start": 3696.0,
        "end": 3699.0
    },
    {
        "text": " yo quiero poder acceder a sus campos y colocar allí un valor.",
        "start": 3700.0,
        "end": 3704.0
    },
    {
        "text": " Y eso se hace con un operador que es el punto.",
        "start": 3706.0,
        "end": 3709.0
    },
    {
        "text": " El puntito es el operador definido por Pascal",
        "start": 3710.0,
        "end": 3713.0
    },
    {
        "text": " y también en otros lenguajes de programación",
        "start": 3713.0,
        "end": 3715.0
    },
    {
        "text": " para acceder a las componentes de un registro.",
        "start": 3715.0,
        "end": 3719.0
    },
    {
        "text": " Que de nuevo, cada componente, cada campo se identifica mediante un nombre.",
        "start": 3720.0,
        "end": 3724.0
    },
    {
        "text": " No mediante un índice, los índices son para qué?",
        "start": 3725.0,
        "end": 3728.0
    },
    {
        "text": " Para los arreglos.",
        "start": 3729.0,
        "end": 3731.0
    },
    {
        "text": " Entonces, si yo hago Q punto signo, significa",
        "start": 3733.0,
        "end": 3737.0
    },
    {
        "text": " me meto dentro de la variable Q",
        "start": 3737.0,
        "end": 3740.0
    },
    {
        "text": " e ingreso al campo signo,",
        "start": 3740.0,
        "end": 3742.0
    },
    {
        "text": " que es el tipo numerado.",
        "start": 3743.0,
        "end": 3745.0
    },
    {
        "text": " Y así colocamos el valor más.",
        "start": 3745.0,
        "end": 3747.0
    },
    {
        "text": " Luego me meto dentro de la variable Q al campo numerador.",
        "start": 3750.0,
        "end": 3755.0
    },
    {
        "text": " Y así guardamos el 4.",
        "start": 3756.0,
        "end": 3758.0
    },
    {
        "text": " No está en la diapositiva, pero si quisiera,",
        "start": 3760.0,
        "end": 3763.0
    },
    {
        "text": " como haría para asignarlo un valor al denominador.",
        "start": 3763.0,
        "end": 3766.0
    },
    {
        "text": " Q punto denominador.",
        "start": 3767.0,
        "end": 3769.0
    },
    {
        "text": " Vamos a suponer que es un 3.",
        "start": 3769.0,
        "end": 3771.0
    },
    {
        "text": " Y yo uso esta notación para acceder al campo ya sea para asignar su valor",
        "start": 3771.0,
        "end": 3776.0
    },
    {
        "text": " o para hacer uso de su valor.",
        "start": 3776.0,
        "end": 3779.0
    },
    {
        "text": " Acá que estoy haciendo, mostrando por pantalla",
        "start": 3780.0,
        "end": 3783.0
    },
    {
        "text": " el valor que está guardado dentro del campo denominador.",
        "start": 3783.0,
        "end": 3786.0
    },
    {
        "text": " En ese ejemplo es un 3.",
        "start": 3787.0,
        "end": 3789.0
    },
    {
        "text": " O sea que siempre que yo quiera acceder a los campos de un record,",
        "start": 3790.0,
        "end": 3794.0
    },
    {
        "text": " lo hago con el punto.",
        "start": 3794.0,
        "end": 3796.0
    },
    {
        "text": " Se pone el nombre de la variable punto y el campo,",
        "start": 3797.0,
        "end": 3800.0
    },
    {
        "text": " el cual estamos queriendo acceder.",
        "start": 3800.0,
        "end": 3803.0
    },
    {
        "text": " Tienes que ir uno por uno.",
        "start": 3804.0,
        "end": 3806.0
    },
    {
        "text": " O sea, con los récords pasa lo mismo que con los enumerados.",
        "start": 3806.0,
        "end": 3809.0
    },
    {
        "text": " No se pueden usar directamente en Riding Rite.",
        "start": 3809.0,
        "end": 3813.0
    },
    {
        "text": " En el caso del record tenes que ir campo por campo.",
        "start": 3813.0,
        "end": 3816.0
    },
    {
        "text": " Sí.",
        "start": 3816.0,
        "end": 3818.0
    },
    {
        "text": " Vamos a suponer que es un 2.",
        "start": 3818.0,
        "end": 3820.0
    },
    {
        "text": " Si el record tenes que ir campo por campo.",
        "start": 3820.0,
        "end": 3822.0
    },
    {
        "text": " Sí.",
        "start": 3822.0,
        "end": 3823.0
    },
    {
        "text": " A través de la desfile,",
        "start": 3823.0,
        "end": 3827.0
    },
    {
        "text": " si se le definió podería, no hayan un muy guía.",
        "start": 3827.0,
        "end": 3830.0
    },
    {
        "text": " Pasa que en la definición del tipo,",
        "start": 3831.0,
        "end": 3834.0
    },
    {
        "text": " nosotros decidimos que signo era un enumerado más menos.",
        "start": 3835.0,
        "end": 3839.0
    },
    {
        "text": " Yo podría haber modelado la realidad de manera diferente",
        "start": 3840.0,
        "end": 3843.0
    },
    {
        "text": " y haber puesto un campo de tipo William.",
        "start": 3843.0,
        "end": 3845.0
    },
    {
        "text": " Sí, podría.",
        "start": 3845.0,
        "end": 3847.0
    },
    {
        "text": " Y cuando vos pones Riding Signo o supuestamente,",
        "start": 3847.0,
        "end": 3853.0
    },
    {
        "text": " vos también la escribir un William,",
        "start": 3853.0,
        "end": 3856.0
    },
    {
        "text": " pero o sea, pasca.",
        "start": 3856.0,
        "end": 3858.0
    },
    {
        "text": " Sí, igual todavía no tiene mucho por qué carrir un William para el Signo,",
        "start": 3858.0,
        "end": 3861.0
    },
    {
        "text": " pero...",
        "start": 3861.0,
        "end": 3862.0
    },
    {
        "text": " Yo, era fuera de lo lógico.",
        "start": 3862.0,
        "end": 3865.0
    },
    {
        "text": " Fueras de lo lógico, sí.",
        "start": 3865.0,
        "end": 3867.0
    },
    {
        "text": " Porque se ha puesto pasca en los restringes y un William.",
        "start": 3867.0,
        "end": 3871.0
    },
    {
        "text": " No los puedo leer, los puedo escribir.",
        "start": 3871.0,
        "end": 3873.0
    },
    {
        "text": " William, si no recuerdo mal,",
        "start": 3874.0,
        "end": 3877.0
    },
    {
        "text": " vos le puedes aplicar Riding, pero no Riding.",
        "start": 3877.0,
        "end": 3880.0
    },
    {
        "text": " Ah, la restrucción tiene sí porque...",
        "start": 3880.0,
        "end": 3883.0
    },
    {
        "text": " Sí, ojo que igual en este ejemplo no era el signo",
        "start": 3883.0,
        "end": 3886.0
    },
    {
        "text": " lo que estaba mostrando,",
        "start": 3886.0,
        "end": 3887.0
    },
    {
        "text": " sino el valor del denominador.",
        "start": 3887.0,
        "end": 3889.0
    },
    {
        "text": " Sí, sí, está, está.",
        "start": 3889.0,
        "end": 3891.0
    },
    {
        "text": " Y más allá del tipo concreto lo que ustedes tienen que quedar es",
        "start": 3891.0,
        "end": 3894.0
    },
    {
        "text": " que para acceder a un campo de un récord se pone,",
        "start": 3894.0,
        "end": 3897.0
    },
    {
        "text": " el nombre de la variable punto el campo en cual estamos queriendo acceder.",
        "start": 3897.0,
        "end": 3900.0
    },
    {
        "text": " Allá, y después allá.",
        "start": 3901.0,
        "end": 3903.0
    },
    {
        "text": " ¿Soy de cristal, de ejemplo, de el récord de cinco treinantes?",
        "start": 3903.0,
        "end": 3908.0
    },
    {
        "text": " Sí.",
        "start": 3908.0,
        "end": 3909.0
    },
    {
        "text": " ¿Soy de la variable no?",
        "start": 3909.0,
        "end": 3912.0
    },
    {
        "text": " ¿Claro?",
        "start": 3912.0,
        "end": 3916.0
    },
    {
        "text": " Y la singa de alto.",
        "start": 3916.0,
        "end": 3917.0
    },
    {
        "text": " ¿No puedo hacer este entre uno y la singa de tu triunf?",
        "start": 3917.0,
        "end": 3920.0
    },
    {
        "text": " Sí, se puede y lo vamos a ver en un rotito.",
        "start": 3920.0,
        "end": 3922.0
    },
    {
        "text": " La asignación entre valores de mismo tipo récord está permitida",
        "start": 3922.0,
        "end": 3926.0
    },
    {
        "text": " y te copia todo lo que está dentro.",
        "start": 3926.0,
        "end": 3928.0
    },
    {
        "text": " Allá.",
        "start": 3928.0,
        "end": 3929.0
    },
    {
        "text": " ¿Te voy a declarar tu triunf?",
        "start": 3930.0,
        "end": 3932.0
    },
    {
        "text": " Sí, y de hecho, te voy a ir ahora.",
        "start": 3932.0,
        "end": 3934.0
    },
    {
        "text": " Dejame que pongo ahí el primer procedimiento y la pregunta.",
        "start": 3934.0,
        "end": 3938.0
    },
    {
        "text": " ¿Qué os voy a dar?",
        "start": 3938.0,
        "end": 3939.0
    },
    {
        "text": " Bueno, vuelvo al anterior.",
        "start": 3939.0,
        "end": 3941.0
    },
    {
        "text": " ¿Vuelvo al anterior?",
        "start": 3941.0,
        "end": 3942.0
    },
    {
        "text": " Bueno, vuelvo dos parantes.",
        "start": 3942.0,
        "end": 3943.0
    },
    {
        "text": " Ahí.",
        "start": 3943.0,
        "end": 3944.0
    },
    {
        "text": " ¿Es el nombre que le dimos a este tipo de datos?",
        "start": 3944.0,
        "end": 3948.0
    },
    {
        "text": " ¿Qué puedo decir?",
        "start": 3948.0,
        "end": 3949.0
    },
    {
        "text": " Si no, dosantes pudieros otro rejito.",
        "start": 3949.0,
        "end": 3951.0
    },
    {
        "text": " ¿Verdas a ponerle así el equipo que no hay otra triunf?",
        "start": 3951.0,
        "end": 3954.0
    },
    {
        "text": " Sí, los campos de un récord pueden ser de cualquier tipo,",
        "start": 3954.0,
        "end": 3958.0
    },
    {
        "text": " de la restricción.",
        "start": 3958.0,
        "end": 3959.0
    },
    {
        "text": " ¿Qué es el ser?",
        "start": 3959.0,
        "end": 3960.0
    },
    {
        "text": " A una cenda del que está el tipo de ser de tuyo,",
        "start": 3960.0,
        "end": 3964.0
    },
    {
        "text": " se tiene el primer asigno.",
        "start": 3964.0,
        "end": 3965.0
    },
    {
        "text": " ¿Pondrías?",
        "start": 3965.0,
        "end": 3966.0
    },
    {
        "text": " Cú.signo y si signo fuera un récord,",
        "start": 3966.0,
        "end": 3969.0
    },
    {
        "text": " pondrías punto y el campo de ese otro récord,",
        "start": 3969.0,
        "end": 3971.0
    },
    {
        "text": " el cual estás queriendo acceder.",
        "start": 3971.0,
        "end": 3972.0
    },
    {
        "text": " Esas construcciones combinadas se pueden hacer sin problemas.",
        "start": 3974.0,
        "end": 3977.0
    },
    {
        "text": " ¿Puedes dar el puntero?",
        "start": 3977.0,
        "end": 3978.0
    },
    {
        "text": " ¿Vas a mandar la antigüesión?",
        "start": 3978.0,
        "end": 3979.0
    },
    {
        "text": " Sí, pero los punteros faltan.",
        "start": 3979.0,
        "end": 3981.0
    },
    {
        "text": " ¿Puede?",
        "start": 3981.0,
        "end": 3982.0
    },
    {
        "text": " Falta, para los punteros.",
        "start": 3982.0,
        "end": 3983.0
    },
    {
        "text": " ¿Vaya en preguntado con los procedimientos y funciones?",
        "start": 3983.0,
        "end": 3986.0
    },
    {
        "text": " ¿Puedes hacer?",
        "start": 3986.0,
        "end": 3987.0
    },
    {
        "text": " ¿Puedes hacer procedimientos y funciones que manipulan récord?",
        "start": 3987.0,
        "end": 3990.0
    },
    {
        "text": " Claro que sí.",
        "start": 3990.0,
        "end": 3991.0
    },
    {
        "text": " Por ejemplo, acá.",
        "start": 3991.0,
        "end": 3993.0
    },
    {
        "text": " Un procedimiento que lee un racional por teclado.",
        "start": 3993.0,
        "end": 3997.0
    },
    {
        "text": " ¿Se le pasa un racional por referencia y está bien?",
        "start": 3997.0,
        "end": 4002.0
    },
    {
        "text": " ¿Qué sea por referencia? ¿Por qué?",
        "start": 4002.0,
        "end": 4004.0
    },
    {
        "text": " ¿Por qué quiero modificarlo?",
        "start": 4004.0,
        "end": 4007.0
    },
    {
        "text": " Quiero cargar sus campos con valores leídos por teclado.",
        "start": 4007.0,
        "end": 4011.0
    },
    {
        "text": " ¿Me definen una variable auxiliar signo?",
        "start": 4011.0,
        "end": 4015.0
    },
    {
        "text": " ¿Sí? ¿Qué puede tomar tres valores posibles?",
        "start": 4015.0,
        "end": 4018.0
    },
    {
        "text": " Menos 1, 0 o 1.",
        "start": 4018.0,
        "end": 4020.0
    },
    {
        "text": " Un surrango.",
        "start": 4020.0,
        "end": 4022.0
    },
    {
        "text": " ¿Ah?",
        "start": 4022.0,
        "end": 4023.0
    },
    {
        "text": " Le pido al usuario que ingrese un signo y que ponga menos 1, 0 o 1.",
        "start": 4023.0,
        "end": 4028.0
    },
    {
        "text": " O sea, que ponga una de esas tres cosas.",
        "start": 4028.0,
        "end": 4031.0
    },
    {
        "text": " Y vamos a suponer que el usuario solamente va a poner una de esas tres cosas.",
        "start": 4031.0,
        "end": 4035.0
    },
    {
        "text": " ¿Ah?",
        "start": 4035.0,
        "end": 4037.0
    },
    {
        "text": " Lo leemos y si el signo es menos 1,",
        "start": 4037.0,
        "end": 4040.0
    },
    {
        "text": " accedemos a Q dentro del campo signo y nosotros ponemos un menos.",
        "start": 4040.0,
        "end": 4046.0
    },
    {
        "text": " De vuelta lo que vimos más temprano,",
        "start": 4046.0,
        "end": 4048.0
    },
    {
        "text": " el enumerado no se puede leer directamente.",
        "start": 4048.0,
        "end": 4050.0
    },
    {
        "text": " Lo tengo que leer indirectamente y yo asignarlo.",
        "start": 4050.0,
        "end": 4054.0
    },
    {
        "text": " ¿Ah?",
        "start": 4054.0,
        "end": 4057.0
    },
    {
        "text": " Y si no le pongo signo más.",
        "start": 4057.0,
        "end": 4060.0
    },
    {
        "text": " ¿Ah bien? Pero de nuevo, puse.",
        "start": 4060.0,
        "end": 4062.0
    },
    {
        "text": " El récord punto, el campo, el cual estamos queriendo acceder.",
        "start": 4062.0,
        "end": 4066.0
    },
    {
        "text": " Bueno, y después le pedimos que ingrese un valor para el denominador y para el numerador.",
        "start": 4067.0,
        "end": 4072.0
    },
    {
        "text": " Q punto denominador, Q punto numerador.",
        "start": 4072.0,
        "end": 4074.0
    },
    {
        "text": " Nuevamente utilizamos la variable punto el campo al cual estamos queriendo acceder.",
        "start": 4074.0,
        "end": 4080.0
    },
    {
        "text": " ¿Ah bien?",
        "start": 4080.0,
        "end": 4082.0
    },
    {
        "text": " Y así cargamos los campos de un récord lecendoro por teclado.",
        "start": 4082.0,
        "end": 4089.0
    },
    {
        "text": " ¿Sí?",
        "start": 4089.0,
        "end": 4092.0
    },
    {
        "text": " Bueno, también podemos mostrar un racional por pantalla y siguen valiendo las mismas reglas de pasaje de parámetros que vimos.",
        "start": 4092.0,
        "end": 4101.0
    },
    {
        "text": " Lo paso por valor, si no lo quiero modificar, lo paso por referencia si lo quiero modificar.",
        "start": 4101.0,
        "end": 4109.0
    },
    {
        "text": " ¿Ah?",
        "start": 4109.0,
        "end": 4110.0
    },
    {
        "text": " Procedimiento mostrar racional le paso un racional y al venir por valor,",
        "start": 4110.0,
        "end": 4116.0
    },
    {
        "text": " asumimos que ya viene como.",
        "start": 4116.0,
        "end": 4119.0
    },
    {
        "text": " Ya viene cargado con valores.",
        "start": 4120.0,
        "end": 4122.0
    },
    {
        "text": " ¿Ah? Bueno, que hacemos acá?",
        "start": 4122.0,
        "end": 4125.0
    },
    {
        "text": " Nos metemos al campo signo con el punto y vemos si hay ahí un menos.",
        "start": 4125.0,
        "end": 4131.0
    },
    {
        "text": " ¿Sí?",
        "start": 4131.0,
        "end": 4132.0
    },
    {
        "text": " Bueno, si hay un menos, mostramos directamente el valor menos.",
        "start": 4132.0,
        "end": 4136.0
    },
    {
        "text": " Si no, nos mostramos nada y asumimos que es una fracción positiva.",
        "start": 4138.0,
        "end": 4143.0
    },
    {
        "text": " Luego mostramos el valor del numerador, la barita y el valor del denominador.",
        "start": 4143.0,
        "end": 4148.0
    },
    {
        "text": " Entonces el usuario va a ver si 4 barra 3 en pantalla.",
        "start": 4148.0,
        "end": 4153.0
    },
    {
        "text": " Hasta acá.",
        "start": 4157.0,
        "end": 4158.0
    },
    {
        "text": " Bueno, hay más ejemplos y los vamos a pasar medio rápido, pero yo puedo hacer tanto procedimientos como funciones que manipulan registros.",
        "start": 4159.0,
        "end": 4169.0
    },
    {
        "text": " Por ejemplo, una función que le doy un racional y me devuelve un intesar, ¿Sí?",
        "start": 4170.0,
        "end": 4177.0
    },
    {
        "text": " Que puede ser 1 o menos 1, dependiendo de su signo.",
        "start": 4177.0,
        "end": 4180.0
    },
    {
        "text": " Entonces, recibo un racional por valor y bueno, consulto que pasa con el signo y veo si devuelvo 1 o menos 1.",
        "start": 4182.0,
        "end": 4190.0
    },
    {
        "text": " O podría ser otro procedimiento que reciba dos racionales pasados como.",
        "start": 4191.0,
        "end": 4198.0
    },
    {
        "text": " Por valor y devuelva como resultado otro racional por referencia.",
        "start": 4199.0,
        "end": 4204.0
    },
    {
        "text": " Estos son lo que se llaman parámetros de entrada, que se pasan por valor y este es un parámetro de salida que obviamente se pasan por referencia.",
        "start": 4206.0,
        "end": 4215.0
    },
    {
        "text": " Lo ideal acá sería hacer una función, pero Pascal impone una restricción que pasaba con las funciones.",
        "start": 4217.0,
        "end": 4223.0
    },
    {
        "text": " El tipo de datos de lo que retorna Pascal obliga que sea un tipo simple.",
        "start": 4224.0,
        "end": 4229.0
    },
    {
        "text": " Por esas razones que hacemos un procedimiento donde el resultado se devuelve por referencia.",
        "start": 4230.0,
        "end": 4235.0
    },
    {
        "text": " En el caso de arriba sí pudimos hacer una función, ¿Por qué?",
        "start": 4236.0,
        "end": 4239.0
    },
    {
        "text": " ¿Por qué queríamos devolver un entero que es un tipo de datos simple?",
        "start": 4240.0,
        "end": 4243.0
    },
    {
        "text": " Bueno, y acá dentro hace toda la cuenta que nos enseñó la maestra en la escuela para sumar fracciones.",
        "start": 4245.0,
        "end": 4250.0
    },
    {
        "text": " El denominador común y después multiplico cruzado, numerador de uno con denominador del otro que se show PPP,",
        "start": 4251.0,
        "end": 4256.0
    },
    {
        "text": " y cargó el resultado en donde?",
        "start": 4257.0,
        "end": 4259.0
    },
    {
        "text": " En los campos de resultado.",
        "start": 4260.0,
        "end": 4262.0
    },
    {
        "text": " Resultado es el record que sacamos por referencia a punto denominador y por acá abajo resultado punto numerador.",
        "start": 4263.0,
        "end": 4271.0
    },
    {
        "text": " Después verificen ustedes que efectivamente esas cuentas están bien hechas.",
        "start": 4272.0,
        "end": 4275.0
    },
    {
        "text": " O sea que los registros pueden utilizarse en procedimientos, pueden utilizarse en funciones,",
        "start": 4276.0,
        "end": 4284.0
    },
    {
        "text": " se puede operar con ellos de la misma manera que se puede operar con cualquier otro tipo de datos.",
        "start": 4285.0,
        "end": 4289.0
    },
    {
        "text": " Y todo depende de qué tantas componentes tengan y qué tamaño tenga cada componente.",
        "start": 4296.0,
        "end": 4302.0
    },
    {
        "text": " Por ejemplo, un racional va a ser bastante más chiquito que un estudiante.",
        "start": 4303.0,
        "end": 4308.0
    },
    {
        "text": " Porque un estudiante tenía cuatro reglos, uno para la c, dula, otro para el nombre, otro para la dirección, otro para lo más acuerdo que más.",
        "start": 4309.0,
        "end": 4316.0
    },
    {
        "text": " O sea, depende del tamaño de sus campos.",
        "start": 4317.0,
        "end": 4320.0
    },
    {
        "text": " No sería para lo que tengo de oro, no sé qué es más costoso a un registro,",
        "start": 4321.0,
        "end": 4325.0
    },
    {
        "text": " en que con un campo solo campo desea un interno, y como es una variable acerte? ¿Qué te oírme?",
        "start": 4325.0,
        "end": 4334.0
    },
    {
        "text": " ¿Por qué carrias hacer un record con un campo solo?",
        "start": 4334.0,
        "end": 4337.0
    },
    {
        "text": " No, no, dos campos. No tiene sentido que ser un record, porque el ideal record es emparejar por lo menos dos valores que tiene sentido juntos.",
        "start": 4337.0,
        "end": 4344.0
    },
    {
        "text": " Si vos queréis usar un entero suelto, declarátele una variable tipo, inté ya.",
        "start": 4344.0,
        "end": 4348.0
    },
    {
        "text": " Sí. ¿Quieres hacer un recistro de la financiación?",
        "start": 4349.0,
        "end": 4354.0
    },
    {
        "text": " No. Cuando vos definís un tipo de datos, sea record, sea reglo, o sea lo que sea, tú estás definiendo, ¿sí?",
        "start": 4355.0,
        "end": 4365.0
    },
    {
        "text": " Un conjunto de posibles valores que se pueden almacenar en variables de ese tipo, estás definiendo almacenamiento de información, no procesamiento.",
        "start": 4366.0,
        "end": 4376.0
    },
    {
        "text": " O sea, dentro del record, definir un procedimiento en la función, no, ni siquiera conpilaría eso.",
        "start": 4377.0,
        "end": 4382.0
    },
    {
        "text": " ¿Más preguntas?",
        "start": 4385.0,
        "end": 4387.0
    },
    {
        "text": " Bueno, hay más ejemplos, por ejemplo, acá definen la fecha como un record formado por año, mes y día.",
        "start": 4390.0,
        "end": 4398.0
    },
    {
        "text": " Fíjense que, en este caso, los tres campos son de valores numéricos.",
        "start": 4401.0,
        "end": 4405.0
    },
    {
        "text": " O sea, que puedes usar un record para representar un racional, un estudiante, una fecha, un punto del plano.",
        "start": 4406.0,
        "end": 4412.0
    },
    {
        "text": " Las aplicaciones son múltiples.",
        "start": 4412.0,
        "end": 4415.0
    },
    {
        "text": " Luego vienen algunas operaciones que manipulan fechas.",
        "start": 4415.0,
        "end": 4419.0
    },
    {
        "text": " Y antes de pasar al práctico,",
        "start": 4422.0,
        "end": 4426.0
    },
    {
        "text": " me falta acá la instrucción width.",
        "start": 4431.0,
        "end": 4434.0
    },
    {
        "text": " Hay una instrucción que tiene Pascal, que permite simplificar el acceso a los campos de un registro, que se llama width.",
        "start": 4435.0,
        "end": 4446.0
    },
    {
        "text": " Esta instrucción permite acceder más fácilmente a los campos.",
        "start": 4447.0,
        "end": 4452.0
    },
    {
        "text": " Vamos a mirar la primera versión que habíamos visto de mostrar racional.",
        "start": 4453.0,
        "end": 4458.0
    },
    {
        "text": " Para acceder así, no que hicimos, cu punto signo.",
        "start": 4459.0,
        "end": 4463.0
    },
    {
        "text": " Para acceder a numerador que hicimos, cu punto numerador.",
        "start": 4464.0,
        "end": 4467.0
    },
    {
        "text": " Para acceder a denominador, cu punto denominador. O sea, siempre poníamos.",
        "start": 4467.0,
        "end": 4471.0
    },
    {
        "text": " El nombre de la variable punto y el campo al que queremos acceder.",
        "start": 4472.0,
        "end": 4475.0
    },
    {
        "text": " Esto está bien, es válido lo pueden usar.",
        "start": 4476.0,
        "end": 4479.0
    },
    {
        "text": " También hay otra alternativa que provee Pascal, que es la siguiente.",
        "start": 4480.0,
        "end": 4483.0
    },
    {
        "text": " Utilizar width.",
        "start": 4484.0,
        "end": 4487.0
    },
    {
        "text": " La instrucción width dice tomar el racional Q y todo lo que tu pongas dentro de Villinen,",
        "start": 4489.0,
        "end": 4496.0
    },
    {
        "text": " no requiere que hagas Q punto, sino que directamente accedés a los campos.",
        "start": 4497.0,
        "end": 4503.0
    },
    {
        "text": " Y por estar dentro del alcance del width, ya se entiende que estás trabajando con los campos de ese récord.",
        "start": 4504.0,
        "end": 4511.0
    },
    {
        "text": " Si yo hago esto, fíjense que acá no puse Q punto signo, puse directamente signo.",
        "start": 4512.0,
        "end": 4518.0
    },
    {
        "text": " No puse Q punto numerador, no puse Q punto denominador, puse directamente numerador y denominador.",
        "start": 4519.0,
        "end": 4525.0
    },
    {
        "text": " Pero debo englobar todo esto dentro del alcance del width.",
        "start": 4526.0,
        "end": 4529.0
    },
    {
        "text": " Lo pueden hacer como quieran, pueden hacerlo usando width,",
        "start": 4532.0,
        "end": 4535.0
    },
    {
        "text": " o pueden hacerlo sin usar width y haciendo Q punto el campo al que quieran acceder son totalmente equivalentes.",
        "start": 4536.0,
        "end": 4542.0
    },
    {
        "text": " Ok, se entendió esto.",
        "start": 4543.0,
        "end": 4546.0
    },
    {
        "text": " Bueno, ojo con algo.",
        "start": 4547.0,
        "end": 4549.0
    },
    {
        "text": " Cuidado, si tengo más de un identificador con el mismo nombre,",
        "start": 4557.0,
        "end": 4562.0
    },
    {
        "text": " uno dentro del récord y otro fuera del récord.",
        "start": 4562.0,
        "end": 4566.0
    },
    {
        "text": " Por ejemplo, Q por ser un racional tenía tres campos, signo numerador y denominador.",
        "start": 4568.0,
        "end": 4575.0
    },
    {
        "text": " Ahora bien, imagínense que es para acceder a los campos del racional queremos hacerlo mediante width.",
        "start": 4577.0,
        "end": 4583.0
    },
    {
        "text": " Si yo dentro del width, hago referencia así, no pascarlo va a interpretar como que signo.",
        "start": 4584.0,
        "end": 4590.0
    },
    {
        "text": " Como el campo signo de la variable Q, no como la variable signo que está por fuera.",
        "start": 4593.0,
        "end": 4598.0
    },
    {
        "text": " O sea, si yo acá quisiera asignarle a esta variable signo, que es de tipo int, yere el valor 1,",
        "start": 4601.0,
        "end": 4607.0
    },
    {
        "text": " acá dentro no me va a compilar porque dentro del width, pascar va a suponer que signo hace referencia que al campo de Q.",
        "start": 4608.0,
        "end": 4615.0
    },
    {
        "text": " Así que, cuidado con estas confusiones.",
        "start": 4617.0,
        "end": 4620.0
    },
    {
        "text": " Si yo quiero diferenciar la variable signo del campo signo, puedo no hacer uso de width,",
        "start": 4621.0,
        "end": 4627.0
    },
    {
        "text": " ¿verdad? Y directamente usar signo igual 1 para asignarlo un valor a este int, y acá poner Q. Signo.",
        "start": 4628.0,
        "end": 4636.0
    },
    {
        "text": " O sea, esa manera se eliminó la ambiüeda.",
        "start": 4637.0,
        "end": 4639.0
    },
    {
        "text": " Dentro del width, si vos querés acceder a una variable que tiene el mismo nombre, que uno de los campos del récord,",
        "start": 4642.0,
        "end": 4648.0
    },
    {
        "text": " pascálte va a dar error porque vas a suponer que está asexidiendo al campo del récord.",
        "start": 4649.0,
        "end": 4653.0
    },
    {
        "text": " Si, si tú eres una variable que no tengan nombre de perpeturos.",
        "start": 4654.0,
        "end": 4657.0
    },
    {
        "text": " Si tú eres una variable PP y acausas PP no hay problema.",
        "start": 4658.0,
        "end": 4660.0
    },
    {
        "text": " ¿Se entendió récord? Bueno, ahora sí, práctico.",
        "start": 4665.0,
        "end": 4668.0
    },
    {
        "text": " ¿A una cosita que me faltó del teórico?",
        "start": 4679.0,
        "end": 4682.0
    },
    {
        "text": " Que me lo habían preguntado hace un ratito y me olvides decirlo.",
        "start": 4688.0,
        "end": 4691.0
    },
    {
        "text": " Si yo tengo dos variables del mismo tipo registro, se puede asignar.",
        "start": 4692.0,
        "end": 4698.0
    },
    {
        "text": " La asignación entre récord del mismo tipo está permitida.",
        "start": 4699.0,
        "end": 4703.0
    },
    {
        "text": " Si P1 y P2 son ambas de tipo punto, dentro de punto que había.",
        "start": 4704.0,
        "end": 4713.0
    },
    {
        "text": " Cordenada X y coordenada Y. Esta asignación funciona como cualquier asignación.",
        "start": 4716.0,
        "end": 4721.0
    },
    {
        "text": " Se toma lo que está a la derecha y se asigna a la izquierda y te lo asigna campo a campo.",
        "start": 4722.0,
        "end": 4728.0
    },
    {
        "text": " O sea, el valor de la coordenada X y P2 va a quedar copiado en la coordenada X y P1 y lo mismo con la coordenada.",
        "start": 4729.0,
        "end": 4736.0
    },
    {
        "text": " O sea que si voces esa asignación entre dos registros del mismo tipo, te hace la copia campo a campo todo en forma automica.",
        "start": 4737.0,
        "end": 4745.0
    },
    {
        "text": " ¿Y vas a preguntar algo?",
        "start": 4746.0,
        "end": 4747.0
    },
    {
        "text": " ¿Pueses asignar con el auto si tienes marca o modelo de color?",
        "start": 4748.0,
        "end": 4751.0
    },
    {
        "text": " Sí, si tienes auto de una modelo de marca, pero hay que frenar de color.",
        "start": 4752.0,
        "end": 4755.0
    },
    {
        "text": " Hay que hacer P1 punto marca, tendrías que meterte campo a campo.",
        "start": 4756.0,
        "end": 4761.0
    },
    {
        "text": " Si voces esa asignación de todo el registro entero, te va a copiar todo como está.",
        "start": 4762.0,
        "end": 4767.0
    },
    {
        "text": " Si voces que les copiar unos campos, si otros no, ahí tienes que usar el punto.",
        "start": 4768.0,
        "end": 4771.0
    },
    {
        "text": " ¿Más preguntas?",
        "start": 4775.0,
        "end": 4776.0
    },
    {
        "text": " ¿Qué no? El punto para el acceso a la celda si la asignación.",
        "start": 4777.0,
        "end": 4782.0
    },
    {
        "text": " No puedes usar operadores relacionales ni nada de eso.",
        "start": 4783.0,
        "end": 4785.0
    },
    {
        "text": " Bueno, ahora sí.",
        "start": 4788.0,
        "end": 4789.0
    },
    {
        "text": " El práctico.",
        "start": 4790.0,
        "end": 4791.0
    },
    {
        "text": " El ejercicio 17.",
        "start": 4792.0,
        "end": 4793.0
    },
    {
        "text": " Se tiene una versión simplificada de la Wikipedia.",
        "start": 4796.0,
        "end": 4800.0
    },
    {
        "text": " O sea, un encyclopedia de artículos.",
        "start": 4802.0,
        "end": 4805.0
    },
    {
        "text": " Es una versión simplificada.",
        "start": 4807.0,
        "end": 4809.0
    },
    {
        "text": " La Wikipedia se enorra.",
        "start": 4810.0,
        "end": 4811.0
    },
    {
        "text": " Vamos a suponer que los artículos solo se pueden escribir en tres idiomas.",
        "start": 4813.0,
        "end": 4817.0
    },
    {
        "text": " Hay Mara, Esperanto y Español.",
        "start": 4818.0,
        "end": 4820.0
    },
    {
        "text": " Por simplicidad vamos a asumir que la Wikipedia tiene una cantidad fija de artículos.",
        "start": 4823.0,
        "end": 4829.0
    },
    {
        "text": " Que está dado por la constante Kant artículos.",
        "start": 4830.0,
        "end": 4832.0
    },
    {
        "text": " Y vamos a suponer que cada artículo tiene un nombre y que el nombre tiene una cantidad fija de letras",
        "start": 4833.0,
        "end": 4839.0
    },
    {
        "text": " dada por una constante Kant letras.",
        "start": 4840.0,
        "end": 4842.0
    },
    {
        "text": " Para representar esta versión simplificada de la Wikipedia, tenemos aquí las siguientes declaraciones.",
        "start": 4845.0,
        "end": 4852.0
    },
    {
        "text": " Dos constantes que definen la cantidad de letras y la cantidad de artículos.",
        "start": 4863.0,
        "end": 4867.0
    },
    {
        "text": " Y después tenemos varios tipos de datos.",
        "start": 4869.0,
        "end": 4871.0
    },
    {
        "text": " Un enumerado que representa los posibles idiomas.",
        "start": 4873.0,
        "end": 4876.0
    },
    {
        "text": " Hay Mara, Esperanto y Español.",
        "start": 4877.0,
        "end": 4879.0
    },
    {
        "text": " El tipo fecha que tiene día, mes y año definidos por esos subrangos que están allí.",
        "start": 4882.0,
        "end": 4888.0
    },
    {
        "text": " Vamos a suponer que la Wikipedia comienza en el año 2001 y de hecho creo que comienza en ese año.",
        "start": 4888.0,
        "end": 4893.0
    },
    {
        "text": " Y después cada artículo se va a almacenar dentro de un récord.",
        "start": 4895.0,
        "end": 4900.0
    },
    {
        "text": " Cada artículo va a tener un nombre y el nombre va a ser un arreglo de que de carácteres.",
        "start": 4902.0,
        "end": 4909.0
    },
    {
        "text": " Cada artículo va a tener un idioma que va a ser de tipo te idioma que es el enumerado que definimos allí.",
        "start": 4911.0,
        "end": 4917.0
    },
    {
        "text": " Cada artículo va a tener la cantidad de visitas que tuvo y la fecha de la última actualización.",
        "start": 4919.0,
        "end": 4926.0
    },
    {
        "text": " Es que todo eso es lo que tiene un artículo dentro.",
        "start": 4929.0,
        "end": 4932.0
    },
    {
        "text": " Además vamos a dibujar ahí un artículo.",
        "start": 4934.0,
        "end": 4936.0
    },
    {
        "text": " Vamos a suponer para simplificar que Kant letras vale cuatro.",
        "start": 4942.0,
        "end": 4946.0
    },
    {
        "text": " O sea que los títulos de los artículos tienen solamente cuatro letras.",
        "start": 4949.0,
        "end": 4954.0
    },
    {
        "text": " Un artículo va a ser un récord que va a tener varios cambios.",
        "start": 4956.0,
        "end": 4962.0
    },
    {
        "text": " El primero de ellos va a ser el nombre.",
        "start": 4966.0,
        "end": 4971.0
    },
    {
        "text": " El segundo va a ser el idioma.",
        "start": 4971.0,
        "end": 4976.0
    },
    {
        "text": " El tercero, la cantidad de visitas.",
        "start": 4980.0,
        "end": 4984.0
    },
    {
        "text": " Y el cuarto, la fecha de la última actualización.",
        "start": 4985.0,
        "end": 4989.0
    },
    {
        "text": " Un artículo en memoria.",
        "start": 4990.0,
        "end": 4993.0
    },
    {
        "text": " Luce así.",
        "start": 4994.0,
        "end": 4995.0
    },
    {
        "text": " Ahora vamos a meternos dentro de cada campo a su vez que cosas nombres.",
        "start": 4996.0,
        "end": 5001.0
    },
    {
        "text": " Un arreglo de carácteres.",
        "start": 5002.0,
        "end": 5004.0
    },
    {
        "text": " Un arreglo de cuatro carácteres. O sea que el campo nombres a su vez está dividido en cuatro celdas.",
        "start": 5005.0,
        "end": 5012.0
    },
    {
        "text": " Y cada una de esas celdas tiene un índice que va de 1 a 4.",
        "start": 5013.0,
        "end": 5019.0
    },
    {
        "text": " El primer campo a su vez es un arreglo.",
        "start": 5020.0,
        "end": 5024.0
    },
    {
        "text": " Por ejemplo, podríamos tener un artículo que habla de el agua.",
        "start": 5029.0,
        "end": 5033.0
    },
    {
        "text": " El segundo campo es el idioma.",
        "start": 5037.0,
        "end": 5039.0
    },
    {
        "text": " Vamos a suponer que el artículo está escrito en español.",
        "start": 5040.0,
        "end": 5042.0
    },
    {
        "text": " O sea que lo que voy a guardar acá va a ser es que es un valor del tipo numerado de idioma.",
        "start": 5043.0,
        "end": 5048.0
    },
    {
        "text": " El tercero es un entero que dice la cantidad de visitas que tuvo el artículo.",
        "start": 5050.0,
        "end": 5057.0
    },
    {
        "text": " Vamos a suponer que tuvo, no sé, 1.238 visitas.",
        "start": 5058.0,
        "end": 5062.0
    },
    {
        "text": " Y lo último es la fecha de la última actualización que a su vez es de tipo de fecha.",
        "start": 5065.0,
        "end": 5072.0
    },
    {
        "text": " Y una fecha su vez que es un record dividido en tres partes, en tres campos.",
        "start": 5073.0,
        "end": 5078.0
    },
    {
        "text": " O sea que la fecha a su vez está dividida en tres.",
        "start": 5079.0,
        "end": 5084.0
    },
    {
        "text": " El primer campo se llama día, el segundo mes y el tercero año.",
        "start": 5085.0,
        "end": 5090.0
    },
    {
        "text": " Y ahí tengo la fecha de la última actualización.",
        "start": 5093.0,
        "end": 5095.0
    },
    {
        "text": " Yo que sé, el 15 de septiembre de 2016 todo esto es que cosa, un artículo.",
        "start": 5096.0,
        "end": 5105.0
    },
    {
        "text": " Taliendo, ¿no?",
        "start": 5105.0,
        "end": 5109.0
    },
    {
        "text": " ¿Sí?",
        "start": 5111.0,
        "end": 5112.0
    },
    {
        "text": " ¿Y qué es la Wikipedia?",
        "start": 5113.0,
        "end": 5114.0
    },
    {
        "text": " Una reglo de artículos.",
        "start": 5118.0,
        "end": 5121.0
    },
    {
        "text": " O sea, una reglo en cuyas celdas hay una cosa de aquellas.",
        "start": 5122.0,
        "end": 5128.0
    },
    {
        "text": " Vamos a suponer que cantar tículos vale no se 30.",
        "start": 5130.0,
        "end": 5133.0
    },
    {
        "text": " Que nuestra versión simplificada de la Wikipedia tiene 30 artículos.",
        "start": 5134.0,
        "end": 5139.0
    },
    {
        "text": " Entonces la Wikipedia sería una reglo.",
        "start": 5145.0,
        "end": 5150.0
    },
    {
        "text": " ¿Dónde qué es lo que hay dentro de cada celda?",
        "start": 5154.0,
        "end": 5157.0
    },
    {
        "text": " Uno de estos. O sea, la Wikipedia sus índices van desde uno hasta 30.",
        "start": 5158.0,
        "end": 5165.0
    },
    {
        "text": " Y lo que hay acá dentro es como que yo le hiciera un zoom y lo que hay acá dentro es todo esto.",
        "start": 5167.0,
        "end": 5175.0
    },
    {
        "text": " Todo esto está metido acá.",
        "start": 5176.0,
        "end": 5178.0
    },
    {
        "text": " Y luego en la celda de al lado tengo otro artículo que tiene la misma estructura.",
        "start": 5179.0,
        "end": 5185.0
    },
    {
        "text": " Es un arreglo de registros.",
        "start": 5185.0,
        "end": 5188.0
    },
    {
        "text": " Vayan imaginándose la segunda tarea.",
        "start": 5191.0,
        "end": 5194.0
    },
    {
        "text": " Estamos suponiendo en este ejemplo que los datos del artículo son nombre y dioma visita y ultima actualización.",
        "start": 5197.0,
        "end": 5203.0
    },
    {
        "text": " Y el nombre es un arreglo de caracteres de tamaño cantletras.",
        "start": 5204.0,
        "end": 5209.0
    },
    {
        "text": " Y estamos suponiendo para este ejemplo que vale cuatro.",
        "start": 5210.0,
        "end": 5214.0
    },
    {
        "text": " Para todos, si todos los artículos tienen títulos de cuatro letras, es una versión simplificada.",
        "start": 5217.0,
        "end": 5222.0
    },
    {
        "text": " Había pregunta ya.",
        "start": 5223.0,
        "end": 5224.0
    },
    {
        "text": " En este ejercicio no. Si yo quisiera manejar nombres de diferentes largones,",
        "start": 5226.0,
        "end": 5231.0
    },
    {
        "text": " necesitamos ver algo que vamos a ver la semana que viene que se arreglo con toque.",
        "start": 5232.0,
        "end": 5235.0
    },
    {
        "text": " Por ahora vamos a suponer que todos los artículos tienen el mismo tamaño en el nombre.",
        "start": 5235.0,
        "end": 5241.0
    },
    {
        "text": " Se logra ni imaginar esto.",
        "start": 5243.0,
        "end": 5245.0
    },
    {
        "text": " Bueno, ¿qué pide este ejercicio?",
        "start": 5246.0,
        "end": 5249.0
    },
    {
        "text": " Implementar una serie de operaciones.",
        "start": 5254.0,
        "end": 5256.0
    },
    {
        "text": " Se van a poner a trabajar en la 1 y en la 2.",
        "start": 5257.0,
        "end": 5260.0
    },
    {
        "text": " La 1 pide implementar una función que se llama es más reciente fecha que recibe dos fechas.",
        "start": 5260.0,
        "end": 5272.0
    },
    {
        "text": " O sea, esta función trabaja exclusivamente sobre el tipo de datos fecha.",
        "start": 5273.0,
        "end": 5277.0
    },
    {
        "text": " Todavía no toca la Wikipedia.",
        "start": 5278.0,
        "end": 5279.0
    },
    {
        "text": " Es una función únicamente para trabajar con fechas.",
        "start": 5280.0,
        "end": 5284.0
    },
    {
        "text": " Yo le paso dos fechas y va a devolver un bullyan.",
        "start": 5284.0,
        "end": 5291.0
    },
    {
        "text": " Y lo que va a devolver es true si y solamente si la fecha F1 es decir la primera,",
        "start": 5292.0,
        "end": 5299.0
    },
    {
        "text": " es más reciente que la fecha F2.",
        "start": 5300.0,
        "end": 5302.0
    },
    {
        "text": " O sea, si está más acá en el tiempo.",
        "start": 5303.0,
        "end": 5305.0
    },
    {
        "text": " Por ejemplo, si F1 fuera, no sé, el 2 de octubre de 2016 y F2 fuera el 28 de septiembre de 2016,",
        "start": 5305.0,
        "end": 5317.0
    },
    {
        "text": " la primera es más reciente que la segunda.",
        "start": 5318.0,
        "end": 5321.0
    },
    {
        "text": " ¿Qué es lo que tendríamos que hacer dentro de esta función?",
        "start": 5322.0,
        "end": 5325.0
    },
    {
        "text": " ir comparando qué cosa.",
        "start": 5326.0,
        "end": 5328.0
    },
    {
        "text": " Primero año, luego mes y luego día.",
        "start": 5329.0,
        "end": 5334.0
    },
    {
        "text": " Y devolvemos true false según si la primera es o no más reciente que la segunda.",
        "start": 5335.0,
        "end": 5339.0
    },
    {
        "text": " Si la primera no es más reciente pero es más reciente, a lo mejor el año, o sea, el mes.",
        "start": 5340.0,
        "end": 5344.0
    },
    {
        "text": " Entonces va a devolver false.",
        "start": 5345.0,
        "end": 5346.0
    },
    {
        "text": " ¿Qué no es más reciente?",
        "start": 5348.0,
        "end": 5349.0
    },
    {
        "text": " No, no, que decía que tiene que ser 15 y 16, pero, o sea, pero el mes sea más reciente que el día.",
        "start": 5350.0,
        "end": 5358.0
    },
    {
        "text": " Si tienen, por ejemplo, el mismo año, el mismo vez, cuál va a ser más reciente.",
        "start": 5359.0,
        "end": 5363.0
    },
    {
        "text": " Aquí tiene menor día.",
        "start": 5363.0,
        "end": 5365.0
    },
    {
        "text": " Entonces, tienen que jugar con esas comparaciones de día, mes año.",
        "start": 5366.0,
        "end": 5368.0
    },
    {
        "text": " Si son iguales, si son iguales, es más reciente.",
        "start": 5369.0,
        "end": 5372.0
    },
    {
        "text": " No, la respuesta false.",
        "start": 5373.0,
        "end": 5374.0
    },
    {
        "text": " ¿Se entendió la primera?",
        "start": 5376.0,
        "end": 5377.0
    },
    {
        "text": " La segunda, esta es más interesante, es un procedimiento, en realidad.",
        "start": 5378.0,
        "end": 5383.0
    },
    {
        "text": " Se llama artículo más reciente.",
        "start": 5384.0,
        "end": 5387.0
    },
    {
        "text": " Le paso toda la Wikipedia, es decir esto.",
        "start": 5388.0,
        "end": 5391.0
    },
    {
        "text": " Le paso un idioma y lo que va a devolver como resultado, pasado en forma de paramento por referencia, es un artículo.",
        "start": 5391.0,
        "end": 5404.0
    },
    {
        "text": " ¿Qué artículo?",
        "start": 5405.0,
        "end": 5407.0
    },
    {
        "text": " El artículo que tiene la fecha más reciente en el idioma especificado.",
        "start": 5408.0,
        "end": 5412.0
    },
    {
        "text": " Por ejemplo, yo le doy la Wikipedia y le paso cuando yo invoco al procedimiento español.",
        "start": 5413.0,
        "end": 5418.0
    },
    {
        "text": " De toda la Wikipedia devolveme el artículo en español con la fecha más reciente.",
        "start": 5418.0,
        "end": 5426.0
    },
    {
        "text": " Eso me va a implicar hacer algún tipo de recorrida en el arregno.",
        "start": 5429.0,
        "end": 5433.0
    },
    {
        "text": " Bueno, ustedes tienen que relacionar.",
        "start": 5435.0,
        "end": 5437.0
    },
    {
        "text": " Tengo que hacer una búsqueda, tengo que hacer una recorrida completa, tengo que hacer un poco de las dos cosas.",
        "start": 5438.0,
        "end": 5444.0
    },
    {
        "text": " Si lo que tengo que hacer es una búsqueda cual era la estructura de control.",
        "start": 5445.0,
        "end": 5448.0
    },
    {
        "text": " Para una búsqueda el wile, si debo hacer una recorrida completa es el for, o sea siguen aplicando las mismas reglas que ya aplicaban.",
        "start": 5449.0,
        "end": 5458.0
    },
    {
        "text": " A la hora de elegir la estructura más adecuada.",
        "start": 5459.0,
        "end": 5462.0
    },
    {
        "text": " Y les voy una pista, dentro de este procedimiento van a tener que llamar a la función anterior.",
        "start": 5463.0,
        "end": 5468.0
    },
    {
        "text": " Porque ustedes van a tener que comparando fechas de artículos.",
        "start": 5469.0,
        "end": 5472.0
    },
    {
        "text": " Entonces van a llamar a la función que hicieron en la parte anterior.",
        "start": 5473.0,
        "end": 5476.0
    },
    {
        "text": " Este procedimiento no muestra por pantalla sino que devuelve por referencia el artículo con la fecha más reciente.",
        "start": 5478.0,
        "end": 5486.0
    },
    {
        "text": " Bueno, se ponen a trabajar, lo piensan bien, no nos va a dar el tiempo de hacer una puesta punto, así que lo hacen y me consultan.",
        "start": 5489.0,
        "end": 5497.0
    }
]